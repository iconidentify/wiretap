<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>WireTap</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <style>
      :root { color-scheme: dark; --primary:#3b82f6; --primary-hover:#2563eb; --secondary:#64748b; --secondary-hover:#475569; --success:#10b981; --warning:#f59e0b; --error:#ef4444; --surface:#1a1a1a; --surface-hover:#2a2a2a; --surface-card:#252525; --text:#ffffff; --text-secondary:#a3a3a3; --border:#404040; --border-hover:#525252; }
      html, body { height: 100%; font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, 'Helvetica Neue', Arial, 'Noto Sans', 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol'; margin: 0; padding: 0; background: var(--surface); color: var(--text); }
      header { padding: 18px 24px; border-bottom: 1px solid var(--border); display: flex; align-items: center; justify-content: space-between; background: var(--surface); box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
      .brand { font-weight: 600; letter-spacing: 0.2px; }
      main { max-width: 1200px; margin: 0 auto; padding: 24px; min-height: calc(100vh - 80px); display: flex; flex-direction: column; }
      .dropzone { border: 2px dashed var(--border); border-radius: 12px; padding: 48px; text-align: center; transition: all .2s ease; background: var(--surface-card); cursor: pointer; }
      .dropzone:hover { border-color: var(--primary); background: var(--surface-hover); }
      .dropzone.dragover { border-color: var(--primary); background: rgba(59, 130, 246, 0.1); border-style: solid; }
      .dz-title { font-size: 18px; margin-bottom: 8px; }
      .dz-sub { opacity: .8; font-size: 14px; }
      .controls { margin-top: 16px; display: flex; gap: 8px; justify-content: center; align-items: center; flex-wrap: wrap; }
      .btn.primary { background: var(--primary); color: white; }
      .btn.primary:hover:not(:disabled) { background: var(--primary-hover); }
      .btn.danger { background: #7f1d1d; color: #fca5a5; border: 1px solid #dc2626; }
      .btn.danger:hover:not(:disabled) { background: #991b1b; }
      .btn:disabled { opacity: 0.5; cursor: not-allowed; }
      .btn { appearance: none; padding: 10px 14px; border-radius: 8px; border: 1px solid var(--border); background: var(--surface); color: var(--text); cursor: pointer; transition: all 0.2s ease; }
      .btn:hover:not(:disabled) { background: var(--surface-hover); border-color: var(--secondary); }
      .output { margin-top: 16px; display: grid; grid-template-columns: 1fr; gap: 12px; flex: 1; }
      .card { border: 1px solid var(--border); border-radius: 12px; overflow: hidden; height: 100%; display: flex; flex-direction: column; background: var(--surface-card); }
      .card header { display: flex; gap: 8px; align-items: center; justify-content: space-between; padding: 16px 20px; border-bottom: 1px solid var(--border); background: var(--surface-card); }
      .card pre { margin: 0; padding: 16px 20px; max-height: 480px; overflow: auto; font-size: 13px; line-height: 1.5; background: var(--surface); color: var(--text); }
      .timeline { position: relative; display: grid; gap: 10px; margin-top: 16px; flex: 1; overflow-y: auto; overflow-x: auto; }
      /* Professional JSON syntax highlighting */
      .hl-key { color: var(--primary); }
      .hl-string { color: var(--success); }
      .hl-number { color: var(--warning); }
      .hl-boolean { color: #7c3aed; }
      .hl-null { color: var(--secondary); font-style: italic; }
      .muted { opacity: .7; }
      .status { font-size: 12px; }
      /* timeline */
      .toolbar { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
      .toolbar input[type="search"] { inline-size: 260px; max-width: 100%; padding: 8px 12px; border-radius: 8px; border: 1px solid var(--border); background: var(--surface); color: var(--text); transition: border-color 0.2s ease; }
      .toolbar input[type="search"]:focus { outline: none; border-color: var(--primary); box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1); }
      .switch { display: inline-flex; align-items: center; gap: 6px; font-size: 13px; }
      .frame { position: relative; border: 1px solid var(--border); background: var(--surface-card); border-radius: 8px; padding: 12px 16px; box-shadow: 0 1px 3px rgba(0,0,0,0.3); transition: all 0.2s ease; }
      .frame:hover { border-color: var(--border-hover); box-shadow: 0 2px 8px rgba(0,0,0,0.4); }
      .frame.c2s { border-left: 4px solid var(--primary); }
      .frame.s2c { border-left: 4px solid var(--success); }
      .group-header { position: sticky; top: 0; z-index: 5; background: var(--surface); border: 1px solid var(--border); padding: 8px 12px; border-radius: 8px; font-weight: 600; color: var(--text); box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
      .meta { display: flex; flex-wrap: wrap; gap: 6px; align-items: center; font-size: 12px; margin-bottom: 8px; }
      .meta-fields { display: flex; flex-wrap: nowrap; gap: 5px; align-items: center; }
      /* Base pill - neutral gray default */
      .pill { 
        padding: 3px 7px; 
        border-radius: 4px; 
        border: 1px solid var(--border); 
        background: var(--surface-hover); 
        color: var(--text-secondary); 
        font-size: 11px; 
        font-family: ui-monospace, Menlo, Monaco, Consolas, monospace; 
        white-space: nowrap; 
        text-align: center; 
        flex-shrink: 0;
        transition: all 0.12s ease;
      }
      .pill:hover { border-color: var(--border-hover); }
      /* Pill label styling */
      .pill-label { color: var(--text-secondary); opacity: 0.7; }
      .pill-value { color: var(--text); }
      /* Fixed min-widths for scanability */
      .pill-dir { min-width: 38px; }
      .pill-type { min-width: 44px; }
      .pill-len { min-width: 32px; }
      .pill-seq { min-width: 44px; }
      .pill-token { min-width: 28px; max-width: 64px; overflow: hidden; text-overflow: ellipsis; }
      .pill-sid { min-width: 36px; max-width: 72px; overflow: hidden; text-overflow: ellipsis; cursor: pointer; }
      .pill-time { min-width: 48px; opacity: 0.7; }
      .pill-crc { min-width: 16px; color: #fff; border-color: var(--error); background: var(--error); font-weight: 600; }
      /* Direction - subtle color hint */
      .dir-c2s { border-left: 2px solid var(--primary); }
      .dir-s2c { border-left: 2px solid var(--success); }
      .pill-dir:hover { border-color: var(--border); background: var(--surface-hover); border-left-color: inherit; }
      /* P3 packet type styling - mostly neutral except errors */
      .type-pill { font-weight: 500; }
      .type-ack, .type-rak, .type-acknow { opacity: 0.75; }
      .type-hbeat { opacity: 0.6; font-style: italic; }
      .type-nak { color: var(--error); border-color: var(--error); background: rgba(239, 68, 68, 0.12); font-weight: 600; }
      .type-init, .type-setup { border-color: var(--warning); }
      .type-ss, .type-ssr { border-color: #a78bfa; }
      .type-reset { color: var(--error); border-color: var(--error); }
      .type-unknown { border-style: dashed; opacity: 0.6; }
      /* Hex byte highlighting */
      .hex { font-family: ui-monospace, Menlo, Monaco, Consolas, monospace; font-size: 12px; white-space: pre-wrap; word-break: break-word; line-height: 1.6; }
      .hex-byte { transition: background 0.08s ease, color 0.08s ease; }
      .hex-byte-hover { background: rgba(59, 130, 246, 0.55); color: #fff; border-radius: 2px; box-shadow: 0 0 0 1px rgba(59,130,246,0.9); }
      .hex-byte-selected { background: rgba(245, 158, 11, 0.45); color: #111; border-radius: 2px; }
      /* Hoverable pill that highlights hex */
      .pill-hoverable { cursor: pointer; }
      .pill-hoverable:hover { background: var(--surface); border-color: var(--primary); }
      .pill-muted { opacity: 0.35; pointer-events: none; }
      .popover { position: absolute; z-index: 20; right: 12px; top: 12px; max-width: 520px; background: var(--surface); color: var(--text); border: 1px solid var(--border); border-radius: 8px; box-shadow: 0 10px 25px rgba(0,0,0,0.1); padding: 12px 16px; display:none; }
      .popover pre { max-height: 300px; overflow:auto; font-size: 12px; margin:0; background: var(--surface-hover); padding: 8px; border-radius: 4px; }
      .actions { margin-left: auto; display: inline-flex; gap: 6px; }
      .iconbtn { appearance: none; border: 1px solid var(--border); background: var(--surface); color: var(--text); border-radius: 6px; padding: 6px 8px; cursor: pointer; font-size: 12px; transition: all 0.2s ease; }
      .iconbtn:hover { background: var(--surface-hover); border-color: var(--secondary); }
      .dot { width: 8px; height: 8px; border-radius: 50%; background: currentColor; box-shadow: 0 0 0 2px rgba(255,255,255,0.8); }
      .timer { opacity: 0.8; }
      #toasts { position: fixed; right: 16px; bottom: 16px; display: grid; gap: 8px; z-index: 50; }
      .toast { padding: 12px 16px; border-radius: 8px; border: 1px solid var(--border); background: var(--surface); box-shadow: 0 10px 30px rgba(0,0,0,0.1); font-size: 13px; color: var(--text); }
      .toast.ok { border-color: rgba(5, 150, 105, 0.3); background: rgba(5, 150, 105, 0.05); }
      .toast.err { border-color: rgba(220, 38, 38, 0.3); background: rgba(220, 38, 38, 0.05); }
      .tab-group { display: flex; gap: 0; border-bottom: 1px solid var(--border); margin-bottom: 16px; }
      .tab { padding: 12px 20px; border: 1px solid transparent; border-bottom: none; cursor: pointer; background: transparent; color: var(--text-secondary); transition: all 0.2s ease; }
      .tab:hover { background: var(--surface-hover); color: var(--text); }
      .tab.active { border-color: var(--border); border-bottom: 2px solid var(--primary); background: var(--surface); color: var(--primary); font-weight: 600; }
      .tab-panel { display: none; }
      .tab-panel.active { display: block; }

      /* Input field styling */
      input[type="number"], input[type="text"] {
        padding: 8px 12px;
        border: 1px solid var(--border);
        border-radius: 6px;
        background: var(--surface);
        color: var(--text);
        font-size: 14px;
        transition: border-color 0.2s ease;
      }
      input[type="number"]:focus, input[type="text"]:focus {
        outline: none;
        border-color: var(--primary);
        box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
      }

      /* StreamId selection and highlighting - neutral by default */
      .pill-sid {
        cursor: pointer;
        position: relative;
        transition: all 0.15s ease;
        color: inherit;
      }
      .pill-sid:hover {
        background: var(--surface);
        border-color: var(--primary);
        color: var(--text);
      }
      .pill-sid:focus {
        outline: none;
        box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
      }
      /* Selected state - only when actively selected */
      .stream-selected {
        background: var(--primary) !important;
        color: white !important;
        border-color: var(--primary) !important;
        font-weight: 600;
      }
      /* Other pills with same streamId when one is selected */
      .stream-highlighted {
        background: rgba(59, 130, 246, 0.12) !important;
        border-color: var(--primary) !important;
        color: var(--primary) !important;
      }
      /* Hover preview before clicking */
      .stream-hover-preview {
        border-color: rgba(59, 130, 246, 0.4) !important;
      }
      /* Frame row highlight when its stream is selected */
      .frame-stream-selected {
        background: rgba(59, 130, 246, 0.04);
      }
      .frames-header {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-top: -4px;
      }
      .frames-header .status-indicator {
        margin-right: 0;
      }
      @keyframes pulse-highlight {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.05); }
      }
      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border-width: 0;
      }

      /* Stream Rail - Visual connector for stream selection */
      .timeline.has-stream-selection {
        padding-left: 48px;
      }
      .stream-rail {
        position: absolute;
        left: 0;
        top: 0;
        width: 40px;
        pointer-events: none;
        animation: rail-reveal 0.25s ease-out;
      }
      .stream-rail > * {
        pointer-events: auto;
      }
      .stream-rail-line {
        position: absolute;
        left: 50%;
        width: 2px;
        background: var(--accent);
        transform: translateX(-50%);
        opacity: 0.5;
      }
      .stream-rail-node {
        position: absolute;
        left: 50%;
        width: 16px;
        height: 2px;
        background: var(--accent);
      }
      .stream-rail-node::before {
        content: '';
        position: absolute;
        left: -5px;
        top: -4px;
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: var(--accent);
        box-shadow: 0 0 0 3px rgba(74, 158, 255, 0.2);
      }
      .stream-rail-action {
        position: fixed;
        bottom: 24px;
        left: 24px;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 2px;
        padding: 12px 16px;
        background: linear-gradient(135deg, var(--accent) 0%, #1d4ed8 100%);
        border: none;
        border-radius: 8px;
        color: white;
        cursor: pointer;
        box-shadow: 0 4px 16px rgba(74, 158, 255, 0.4);
        transition: transform 0.2s, box-shadow 0.2s;
        z-index: 1000;
      }
      .stream-rail-action:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(74, 158, 255, 0.5);
      }
      .stream-rail-action-icon {
        font-size: 16px;
      }
      .stream-rail-action-count {
        font-size: 11px;
        font-weight: 600;
        opacity: 0.9;
      }
      @keyframes rail-reveal {
        from { opacity: 0; transform: translateX(-10px); }
        to { opacity: 1; transform: translateX(0); }
      }

      /* FDO Modal */
      #fdo-modal {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.8);
        z-index: 100;
        display: none;
        align-items: center;
        justify-content: center;
        padding: 20px;
      }
      #fdo-modal.active {
        display: flex;
      }
      .fdo-content {
        background: var(--surface-card);
        border: 1px solid var(--border);
        border-radius: 12px;
        max-width: 900px;
        width: 100%;
        max-height: 80vh;
        display: flex;
        flex-direction: column;
        box-shadow: 0 20px 50px rgba(0,0,0,0.5);
      }
      .fdo-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 16px 20px;
        border-bottom: 1px solid var(--border);
      }
      .fdo-header h2 {
        margin: 0;
        font-size: 18px;
        font-weight: 600;
      }
      .fdo-body {
        flex: 1;
        overflow: auto;
        padding: 0;
      }
      .fdo-source {
        font-family: ui-monospace, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;
        font-size: 13px;
        line-height: 1.6;
        margin: 0;
        padding: 20px;
        background: var(--surface);
        color: var(--text);
        white-space: pre;
        overflow-x: auto;
      }
      .fdo-actions {
        padding: 16px 20px;
        border-top: 1px solid var(--border);
        display: flex;
        gap: 8px;
        justify-content: flex-end;
      }

      /* Session disk usage indicator */
      .disk-usage {
        display: flex;
        align-items: center;
        gap: 4px;
      }
      .disk-icon {
        opacity: 0.7;
      }

      /* Connection Tabs - Horizontal Layout */
      .connection-tabs-container {
        border-bottom: 1px solid var(--border);
        background: var(--surface-card);
        margin-bottom: 16px;
        overflow-x: auto;
        overflow-y: hidden;
        display: none; /* Hidden by default */
      }
      .connection-tabs {
        display: flex;
        gap: 0;
        padding: 0 24px;
        min-height: 48px;
        overflow-x: auto;
        scrollbar-width: thin;
        position: relative;
      }
      .connection-tabs::-webkit-scrollbar {
        height: 4px;
      }
      .connection-tabs::-webkit-scrollbar-track {
        background: transparent;
      }
      .connection-tabs::-webkit-scrollbar-thumb {
        background: var(--border);
        border-radius: 2px;
      }
      .connection-tabs::-webkit-scrollbar-thumb:hover {
        background: var(--primary);
      }

      /* Overflow indicators */
      .connection-tabs-container::after {
        content: "→";
        position: absolute;
        right: 50px;
        top: 50%;
        transform: translateY(-50%);
        color: var(--text-secondary);
        font-size: 14px;
        opacity: 0;
        transition: opacity 0.2s ease;
        pointer-events: none;
        z-index: 2;
      }
      .connection-tabs-container.has-overflow::after {
        opacity: 1;
      }
      .connection-tab {
        position: relative;
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 12px 16px;
        border: none;
        border-bottom: 2px solid transparent;
        background: transparent;
        color: var(--text-secondary);
        font-size: 14px;
        cursor: pointer;
        transition: all 0.2s ease;
        white-space: nowrap;
        border-radius: 0;
      }
      .connection-tab:hover {
        background: var(--surface-hover);
        color: var(--text);
      }
      .connection-tab.active {
        color: var(--primary);
        border-bottom-color: var(--primary);
        font-weight: 600;
        background: rgba(59, 130, 246, 0.05);
      }
      .connection-tab.all.active {
        color: var(--success);
        border-bottom-color: var(--success);
        background: rgba(5, 150, 105, 0.05);
      }
      .connection-tab:focus {
        outline: 2px solid var(--primary);
        outline-offset: 2px;
      }
      .connection-count {
        opacity: 0.7;
        font-size: 12px;
        margin-left: 4px;
      }
      .duration-badge {
        opacity: 0.6;
        font-size: 11px;
        margin-left: 6px;
        color: var(--text-tertiary);
      }
      .connection-status-dot {
        width: 6px;
        height: 6px;
        border-radius: 50%;
        background: var(--success);
        margin-left: 6px;
        flex-shrink: 0;
      }
      .connection-status-dot.inactive {
        background: var(--secondary);
      }

      /* Clear Recent Button */
      .clear-recent-btn {
        position: absolute;
        right: 12px;
        top: 50%;
        transform: translateY(-50%);
        padding: 6px 12px;
        border: 1px solid var(--border);
        background: var(--surface);
        color: var(--text-secondary);
        font-size: 12px;
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.2s ease;
        z-index: 1;
      }
      .clear-recent-btn:hover {
        background: var(--surface-hover);
        color: var(--text);
        border-color: var(--primary);
      }
      .clear-recent-btn:focus {
        outline: 2px solid var(--primary);
        outline-offset: 2px;
      }
      .connection-tabs-container {
        position: relative;
      }

      /* Port-based color coding */
      .connection-tab[data-port="5190"] {
        border-left: 3px solid var(--success);
      }
      .connection-tab[data-port="80"] {
        border-left: 3px solid #3b82f6; /* Blue */
      }
      .connection-tab[data-port="443"] {
        border-left: 3px solid #9333ea; /* Purple */
      }
      .connection-tab[data-port="8080"] {
        border-left: 3px solid #f59e0b; /* Amber */
      }
      .connection-tab[data-port="3306"] {
        border-left: 3px solid #ef4444; /* Red */
      }
      .connection-tab[data-port="22"] {
        border-left: 3px solid #06b6d4; /* Cyan */
      }

      /* Closed connection styling */
      .connection-tab.closed {
        opacity: 0.6;
        background: rgba(0, 0, 0, 0.02);
        border-left-color: var(--secondary) !important;
      }
      .connection-tab.closed:hover {
        opacity: 0.8;
        background: var(--surface-hover);
      }
      .connection-tab.closed .connection-label {
        color: var(--text-tertiary);
      }
      .connection-tab.closed .duration-badge,
      .connection-tab.closed .connection-count {
        opacity: 0.5;
      }

      /* Sidebar Layout */
      .proxy-layout {
        display: flex;
        height: calc(100vh - 160px);
        gap: 0;
      }

      .connections-sidebar {
        width: 280px;
        min-width: 280px;
        background: var(--surface-card);
        border-right: 1px solid var(--border);
        display: flex;
        flex-direction: column;
        transition: width 0.3s ease, min-width 0.3s ease;
        overflow: hidden;
      }

      .connections-sidebar.collapsed {
        width: 48px;
        min-width: 48px;
      }

      .sidebar-header {
        padding: 16px;
        border-bottom: 1px solid var(--border);
        display: flex;
        align-items: center;
        justify-content: space-between;
        background: var(--surface);
      }

      .sidebar-header h3 {
        margin: 0;
        font-size: 14px;
        font-weight: 600;
        color: var(--text);
        white-space: nowrap;
        overflow: hidden;
        transition: opacity 0.3s ease;
      }

      .connections-sidebar.collapsed .sidebar-header h3 {
        opacity: 0;
      }

      .sidebar-toggle {
        border: none;
        background: transparent;
        color: var(--text-secondary);
        cursor: pointer;
        padding: 4px;
        border-radius: 4px;
        transition: all 0.2s ease;
        flex-shrink: 0;
      }

      .sidebar-toggle:hover {
        background: var(--surface-hover);
        color: var(--text);
      }

      .toggle-icon {
        display: inline-block;
        transition: transform 0.3s ease;
        font-size: 14px;
      }

      .connections-sidebar.collapsed .toggle-icon {
        transform: rotate(180deg);
      }

      .sidebar-content {
        flex: 1;
        overflow-y: auto;
        padding: 8px;
      }

      .main-content {
        flex: 1;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        min-height: 0;
      }

      /* Fix scrolling in Live Proxy layout */
      .main-content > .output {
        min-height: 0;
      }

      .main-content > .output > .card {
        min-height: 0;
      }

      /* Connection Items */
      .connection-section {
        margin-bottom: 8px;
      }

      .connection-item {
        width: 100%;
        border: none;
        background: transparent;
        padding: 12px;
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.2s ease;
        text-align: left;
        display: flex;
        align-items: center;
        gap: 12px;
        position: relative;
      }

      .connection-item:hover {
        background: var(--surface-hover);
      }

      .connection-item.active {
        background: rgba(59, 130, 246, 0.1);
        color: var(--primary);
        font-weight: 500;
      }

      .connection-item.all.active {
        background: rgba(5, 150, 105, 0.1);
        color: var(--success);
      }

      .connection-info {
        flex: 1;
        min-width: 0;
      }

      .connection-name {
        display: block;
        font-size: 14px;
        color: var(--text);
        margin-bottom: 2px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .connection-meta {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 12px;
        color: var(--text-secondary);
      }

      .frame-count {
        opacity: 0.8;
      }

      .connection-duration {
        opacity: 0.6;
      }

      /* Connection Groups */
      .connection-group {
        margin-bottom: 16px;
      }

      .group-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 8px 12px 4px 12px;
        border-bottom: 1px solid var(--border);
        margin-bottom: 8px;
      }

      .group-title {
        font-size: 12px;
        font-weight: 600;
        color: var(--text-secondary);
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .group-count {
        font-size: 11px;
        color: var(--text-tertiary);
      }

      .clear-recent-btn-sidebar {
        border: none;
        background: transparent;
        color: var(--text-tertiary);
        cursor: pointer;
        font-size: 11px;
        padding: 2px 6px;
        border-radius: 3px;
        transition: all 0.2s ease;
      }

      .clear-recent-btn-sidebar:hover {
        background: var(--surface-hover);
        color: var(--error);
      }

      .group-content {
        display: flex;
        flex-direction: column;
        gap: 2px;
      }

      /* Connection Status Indicators */
      .connection-status {
        width: 6px;
        height: 6px;
        border-radius: 50%;
        flex-shrink: 0;
      }

      .connection-status.active {
        background: var(--success);
      }

      .connection-status.closed {
        background: var(--secondary);
      }

      /* Port Color Indicators */
      .port-indicator {
        width: 3px;
        height: 20px;
        border-radius: 1px;
        flex-shrink: 0;
      }

      .port-indicator[data-port="5190"] { background: var(--success); }
      .port-indicator[data-port="80"] { background: #3b82f6; }
      .port-indicator[data-port="443"] { background: #9333ea; }
      .port-indicator[data-port="8080"] { background: #f59e0b; }
      .port-indicator[data-port="3306"] { background: #ef4444; }
      .port-indicator[data-port="22"] { background: #06b6d4; }

      /* Collapsed sidebar styles */
      .connections-sidebar.collapsed .sidebar-content {
        padding: 4px;
      }

      .connections-sidebar.collapsed .connection-name,
      .connections-sidebar.collapsed .connection-meta,
      .connections-sidebar.collapsed .group-header,
      .connections-sidebar.collapsed .connection-search {
        display: none;
      }

      .connections-sidebar.collapsed .connection-item {
        padding: 8px;
        justify-content: center;
      }

      /* Search Input */
      .connection-search {
        margin-bottom: 12px;
        padding: 0 4px;
      }

      .search-input {
        width: 100%;
        border: 1px solid var(--border);
        background: var(--surface);
        color: var(--text);
        padding: 8px 12px;
        border-radius: 6px;
        font-size: 13px;
        transition: border-color 0.2s ease;
      }

      .search-input:focus {
        outline: none;
        border-color: var(--primary);
      }

      /* Compact Session Metadata Bar */
      .session-metadata-compact {
        padding: 12px 24px;
        background: var(--surface-card);
        border-bottom: 1px solid var(--border);
        font-size: 12px;
        color: var(--text-secondary);
        display: none; /* Hidden by default */
        align-items: center;
        gap: 16px;
        flex-wrap: wrap;
        flex-shrink: 0;
      }
      .session-metadata-compact .metric {
        display: flex;
        align-items: center;
        gap: 4px;
      }
      .session-metadata-compact .metric-value {
        font-weight: 600;
        color: var(--text);
      }
      .session-metadata-compact .status-warning {
        color: var(--error);
        font-weight: 600;
      }
      .session-metadata-compact .separator {
        color: var(--border);
        margin: 0 4px;
      }

      /* Proxy Controls */
      .proxy-controls {
        margin-bottom: 16px;
        display: none; /* Hidden by default, shown when proxy tab is active */
      }
      .proxy-status-section {
        padding: 12px 24px;
        background: var(--surface-card);
        border: 1px solid var(--border);
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 16px;
        flex-wrap: wrap;
      }
      .proxy-status {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 14px;
      }
      .status-indicator {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .status-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: var(--secondary);
        transition: background-color 0.2s ease;
      }
      .status-dot.running {
        background: var(--success);
        box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.2);
      }
      .proxy-actions {
        display: flex;
        gap: 8px;
        align-items: center;
      }

      /* Mobile Responsive for Tabs */
      @media (max-width: 768px) {
        .connection-tabs {
          padding: 0 12px;
          -webkit-overflow-scrolling: touch;
          scrollbar-width: thin;
        }
        .connection-tab {
          padding: 10px 12px;
          font-size: 13px;
        }
        .session-metadata-compact {
          padding: 10px 12px;
          font-size: 11px;
          gap: 12px;
        }
      }

      /* Responsive Design for Sidebar */
      @media (max-width: 1024px) {
        .proxy-layout {
          height: calc(100vh - 120px);
        }
        .connections-sidebar {
          width: 240px;
          min-width: 240px;
        }
      }

      @media (max-width: 768px) {
        .proxy-layout {
          flex-direction: column;
          height: auto;
        }
        .connections-sidebar {
          width: 100%;
          min-width: 100%;
          height: 200px;
          border-right: none;
          border-bottom: 1px solid var(--border);
        }
        .connections-sidebar.collapsed {
          height: 48px;
          width: 100%;
          min-width: 100%;
        }
        .sidebar-content {
          padding: 4px 8px;
        }
        .connection-item {
          padding: 8px;
          font-size: 13px;
        }
        .connection-name {
          font-size: 13px;
        }
        .connection-meta {
          font-size: 11px;
        }
        .main-content {
          flex: 1;
        }
      }

      /* Very small screens - stack metadata */
      @media (max-width: 480px) {
        .session-metadata-compact {
          flex-direction: column;
          align-items: flex-start;
          gap: 6px;
          padding: 8px 12px;
        }
        .session-metadata-compact .separator {
          display: none;
        }
        .connections-sidebar {
          height: 150px;
        }
        .sidebar-header {
          padding: 8px 12px;
        }
        .sidebar-header h3 {
          font-size: 13px;
        }
        .connection-item {
          padding: 6px 8px;
        }
        .port-indicator {
          width: 2px;
          height: 16px;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <div class="brand">WireTap</div>
    </header>
    <main>
      <div class="tab-group">
        <div class="tab active" data-tab="proxy">Live Proxy</div>
        <div class="tab" data-tab="pcap">PCAP Analyzer</div>
      </div>
      <div id="tab-proxy" class="tab-panel active">
        <div class="proxy-layout">
          <!-- Connections Sidebar -->
          <div class="connections-sidebar" id="connections-sidebar">
            <div class="sidebar-header">
              <h3>Connections</h3>
              <button class="sidebar-toggle" id="sidebar-toggle" title="Toggle sidebar">
                <span class="toggle-icon">⟨</span>
              </button>
            </div>

            <div class="sidebar-content">
              <!-- Connection Search -->
              <div class="connection-search" id="connection-search" style="display: none;">
                <input type="text" placeholder="Search connections..." class="search-input" id="search-connections">
              </div>

              <!-- All Connections Option -->
              <div class="connection-section">
                <button role="tab"
                        aria-selected="true"
                        aria-controls="timeline-proxy"
                        id="connection-item-all"
                        class="connection-item all active"
                        data-connection-id="null"
                        tabindex="0">
                  <div class="connection-info">
                    <span class="connection-name">All Connections</span>
                    <span class="connection-meta">
                      <span class="frame-count">(0)</span>
                    </span>
                  </div>
                </button>
              </div>

              <!-- Active Connections Section -->
              <div class="connection-group" id="active-connections-group" style="display: none;">
                <div class="group-header">
                  <span class="group-title">Active</span>
                  <span class="group-count" id="active-group-count">(0)</span>
                </div>
                <div class="group-content" id="active-connections-list"></div>
              </div>

              <!-- Recent Connections Section -->
              <div class="connection-group" id="recent-connections-group" style="display: none;">
                <div class="group-header">
                  <span class="group-title">Recent</span>
                  <span class="group-count" id="recent-group-count">(0)</span>
                  <button class="clear-recent-btn-sidebar" id="clear-recent-btn-sidebar" title="Clear recent connections">Clear</button>
                </div>
                <div class="group-content" id="recent-connections-list"></div>
              </div>
            </div>
          </div>

          <!-- Main Content Area -->
          <div class="main-content" id="main-content">
            <!-- Compact Session Metadata Bar -->
            <div class="session-metadata-compact" id="session-metadata-compact">
              <span class="metric">
                <span class="metric-value" id="session-frames">0</span> frames
              </span>
              <span class="separator">•</span>
              <span class="metric">
                <span class="metric-value" id="connection-count">0</span> connections
              </span>
              <span class="separator">•</span>
              <span class="metric">
                <span class="metric-value" id="session-duration">00:00:00</span>
              </span>
              <span class="separator">•</span>
              <span class="metric disk-usage">
                <span class="disk-icon">&#128190;</span>
                <span class="metric-value" id="session-disk-size">0 KB</span>
              </span>
              <span class="separator">•</span>
              <span class="metric">
                <span id="sequence-status">Sequence: OK</span>
              </span>
            </div>

            <!-- Proxy Timeline and Output -->
            <section class="output">
              <div class="card">
                <header>
                  <div class="frames-header">
                    <span class="status-indicator compact">
                      <span class="status-dot" id="proxy-status-dot"></span>
                    </span>
                    <span>Latest Frames (Newest First) <span id="file-type-indicator" style="font-size: 12px; opacity: 0.7; font-weight: normal;"></span></span>
                  </div>
                  <div class="actions">
                    <button id="decompile-stream-proxy" class="iconbtn" style="display: none;">Decompile Stream</button>
                    <button id="clear" class="iconbtn">Clear</button>
                    <button id="exportJsonl" class="iconbtn">Export JSONL</button>
                  </div>
                </header>
                <div id="timeline-proxy" class="timeline" role="tabpanel" aria-labelledby="connection-item-all"></div>
              </div>
            </section>
          </div> <!-- End main-content -->
        </div> <!-- End proxy-layout -->
      </div>
      <div id="tab-pcap" class="tab-panel">
        <div id="dz" class="dropzone">
          <div class="dz-title">Drop a PCAP or JSONL file here</div>
          <div class="dz-sub">or click to choose</div>
          <input id="file" type="file" accept=".pcap,.jsonl,application/vnd.tcpdump.pcap,application/x-ndjson" hidden />
        </div>

        <!-- PCAP Timeline and Output -->
        <section class="output">
          <div class="card">
            <header>
              <div>Latest Frames (Newest First) <span id="file-type-indicator" style="font-size: 12px; opacity: 0.7; font-weight: normal;"></span></div>
              <div class="actions">
                <button id="decompile-stream-pcap" class="iconbtn" style="display: none;">Decompile Stream</button>
                <button id="clear" class="iconbtn">Clear</button>
                <button id="exportJsonl" class="iconbtn">Export JSONL</button>
              </div>
            </header>
            <div id="timeline-pcap" class="timeline" style="display:none"></div>
          </div>
        </section>
      </div>
    </main>

    <div id="toasts"></div>
    <!-- ARIA live region for screen reader announcements -->
    <div id="connection-announcer" aria-live="polite" aria-atomic="true" style="position: absolute; left: -10000px; width: 1px; height: 1px; overflow: hidden;"></div>

    <!-- FDO Source Modal -->
    <div id="fdo-modal">
      <div class="fdo-content">
        <div class="fdo-header">
          <h2>FDO Decompiled Source</h2>
          <button class="iconbtn" id="fdo-close">Close</button>
        </div>
        <div class="fdo-body">
          <pre class="fdo-source" id="fdo-source-text"></pre>
        </div>
        <div class="fdo-actions">
          <button class="btn" id="fdo-copy">Copy to Clipboard</button>
        </div>
      </div>
    </div>

    <script>
      const dz = document.getElementById('dz');
      const fileInput = document.getElementById('file');
      // virtual download link created on demand
      let downloadLink = null;
      const timelinePcap = document.getElementById('timeline-pcap');
      const timelineProxy = document.getElementById('timeline-proxy');

      const clearBtn = document.getElementById('clear');
      const exportJsonlBtn = document.getElementById('exportJsonl');

      
      
      // Check initial proxy status and start streaming if running
      async function checkInitialProxyStatus() {
        // Immediately check proxy status and start streaming if running
        console.log('Checking proxy status...');
        try {
          const res = await fetch('/api/proxy/status');
          const status = await res.json();
          if (status.running) {
            console.log('Proxy is running, starting live stream immediately...');
            proxyRunning = true;

            // Load existing connections
            await loadConnections();

            // Load existing session frames (now JSONL stream)
            console.log('Loading existing session frames...');
            try {
              const framesRes = await fetch('/api/session/frames');
              if (framesRes.ok) {
                const text = await framesRes.text();
                const lines = text.trim().split('\n').filter(line => line.trim());
                console.log(`Loading ${lines.length} existing session frames...`);

                // Display existing frames
                for (const line of lines) {
                  try {
                    const obj = JSON.parse(line);
                    const frameData = { obj, raw: line, isLive: false };
                    activeFrames().push(frameData);
                    renderFrame(obj, line, document.getElementById('timeline-proxy'));
                  } catch (e) {
                    console.warn('Failed to parse session frame:', e);
                  }
                }

                // As a backup, if no frames were counted, set it manually
                if (totalFramesReceived === 0 && lines.length > 0) {
                  totalFramesReceived = lines.length;
                  updateSessionMetadata();
                }

                if (lines.length > 0) {
                  toast(`Loaded ${lines.length} frames from current session`, 'ok');
                }

                // Apply current connection filter if active
                filterFramesByConnection();
              }
            } catch (err) {
              console.warn('Failed to load session frames:', err);
            }

            // Start live streaming immediately without delay
            startLive();
          } else {
            proxyRunning = false;
          }
        } catch (err) {
          console.warn('Failed to check proxy status:', err);
          proxyRunning = false;
        }
      }


      function toast(msg, kind){ const t=document.createElement('div'); t.className='toast ' + (kind||''); t.textContent=msg; document.getElementById('toasts').appendChild(t); setTimeout(()=>{ t.remove(); }, 3500); }

      // P3 knowledge constants (summaries derived from protocol docs)
      const P3_INFO = {
        types: {
          DATA: 'Carries app payload. tx increments; rx piggybacks cumulative ACK.',
          ACK: 'Standalone ACK when no data to piggyback; frees window.',
          NAK: 'Negative ACK. Triggers retransmit (Go-Back-N). See reason.',
          HBEAT: 'Heartbeat when unacked data and no packets seen; expect ACK.',
          SS: 'Synchronize Sequence; ask peer for state (await SSR).',
          SSR: 'Response to SS; summarizes receive state; clears queued NAKs.',
          INIT: 'Client handshake; seq starts at 0x7F then wraps to 0x10.',
          RESET: 'Reset state (legacy).',
          RAK: 'Reset ACK (legacy).',
          SETUP: 'Session setup (legacy).',
          ACKNOW: 'Control ACK (legacy)'
        },
        nakReasons: {
          CRC_ERROR: 'CRC failure: corrupted frame. Sender should retransmit from earliest missing.',
          SEQUENCE_ERROR: 'Out-of-order or missing sequence. Sender retransmits from missing seq.',
          LENGTH_ERROR: 'Malformed length/header.',
          PACKET_BUILD_ERROR: 'Peer failed to build a packet (internal).'
        },
        seq: {
          range: 'Valid seq range 0x10–0x7F (wrap).',
          tx: 'TX = sender’s packet sequence (increments on DATA only).',
          rx: 'RX = cumulative ACK: last in-order seq received from peer.'
        }
      };
      const TOKEN_INFO = {
        AT: 'Atom stream (FDO forms/control)',
        at: 'Atom stream variant',
        AA: 'Article/text atom stream',
        F9: 'XFER final data chunk',
        xG: 'XFER-level ACK from client',
        eJ: 'TA_OUT success verdict',
        eK: 'TA_OUT negative verdict',
        tj: 'XFER metadata (TJ_IN)',
        tf: 'XFER start (TF_IN)'
      };

      // FDO Modal functions
      function showFdoModal(source, title) {
        const modal = document.getElementById('fdo-modal');
        const sourceEl = document.getElementById('fdo-source-text');
        const titleEl = modal.querySelector('.fdo-header h2');
        sourceEl.textContent = source;
        if (title) {
          titleEl.textContent = title;
        } else {
          titleEl.textContent = 'FDO Decompiled Source';
        }
        modal.classList.add('active');
      }

      function hideFdoModal() {
        const modal = document.getElementById('fdo-modal');
        modal.classList.remove('active');
      }

      // FDO modal event listeners
      document.getElementById('fdo-close').addEventListener('click', hideFdoModal);
      document.getElementById('fdo-copy').addEventListener('click', async () => {
        const source = document.getElementById('fdo-source-text').textContent;
        await navigator.clipboard.writeText(source);
        const btn = document.getElementById('fdo-copy');
        const orig = btn.textContent;
        btn.textContent = 'Copied!';
        setTimeout(() => btn.textContent = orig, 800);
      });
      // Close modal on ESC key
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          hideFdoModal();
        }
      });
      // Close modal on background click
      document.getElementById('fdo-modal').addEventListener('click', (e) => {
        if (e.target.id === 'fdo-modal') {
          hideFdoModal();
        }
      });

      // Session management functions

      let selectedFile = null;
      let proxyRunning = false;

      // Session metadata tracking
      let sessionStartTime = null;
      let pcapStartTime = null;
      let totalFramesReceived = 0;
      let lastSequenceNumber = null;
      let sequenceGaps = 0;

      // First frame timestamp tracking for relative time display
      let firstProxyFrameTs = null;
      let firstPcapFrameTs = null;

      const framesPcap = []; // {obj, raw}
      const framesProxy = []; // {obj, raw}
      function isProxyActive() {
        const t = document.querySelector('.tab.active');
        return t && t.dataset.tab === 'proxy' && proxyRunning;
      }
      function activeFrames() { return isProxyActive() ? framesProxy : framesPcap; }

      // Get the correct decompile stream button based on active tab
      function getDecompileStreamButton() {
        const activeTab = document.querySelector('.tab.active');
        if (activeTab && activeTab.dataset.tab === 'proxy') {
          return document.getElementById('decompile-stream-proxy');
        }
        return document.getElementById('decompile-stream-pcap');
      }

      // Connection management
      let connections = []; // Array of connection objects
      let selectedConnectionId = null; // null = "All Connections"

      // StreamId filtering state
      let activeStreamId = null;

      // Session metadata functions
      function updateSessionMetadata() {

        // Update frame count
        document.getElementById('session-frames').textContent = totalFramesReceived.toLocaleString();

        // Update sequence status
        const sequenceStatus = sequenceGaps > 0 ? `${sequenceGaps} gaps` : 'OK';
        document.getElementById('sequence-status').textContent = sequenceStatus;


        // Update session duration
        if (sessionStartTime) {
          const duration = Math.floor((Date.now() - sessionStartTime) / 1000);
          const hours = Math.floor(duration / 3600);
          const minutes = Math.floor((duration % 3600) / 60);
          const seconds = duration % 60;
          document.getElementById('session-duration').textContent =
            `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        // Update disk size periodically by fetching session info
        updateDiskSize();
      }

      // Update disk size from server
      let lastDiskSizeUpdate = 0;
      async function updateDiskSize() {
        // Throttle disk size updates to every 2 seconds
        const now = Date.now();
        if (now - lastDiskSizeUpdate < 2000) return;
        lastDiskSizeUpdate = now;

        try {
          const res = await fetch('/api/sessions/current');
          const data = await res.json();
          if (data.active && data.session) {
            document.getElementById('session-disk-size').textContent = data.session.formattedSize || '0 KB';
          }
        } catch (err) {
          // Ignore errors silently
        }
      }

      // Connection management functions
      function generateSmartLabel(conn, connections) {
        // Check for duplicate IPs and generate smart labels
        const sameIpConnections = connections.filter(c => c.sourceIp === conn.sourceIp);

        // If non-standard port, show port
        if (conn.sourcePort !== 5190) {
          return `${conn.sourceIp}:${conn.sourcePort}`;
        }

        // If multiple connections from same IP, add index
        if (sameIpConnections.length > 1) {
          const index = sameIpConnections.indexOf(conn) + 1;
          return `${conn.sourceIp} #${index}`;
        }

        // Otherwise, just show IP
        return conn.sourceIp;
      }

      function updateConnectionsSidebar() {
        const sidebar = document.getElementById('connections-sidebar');
        const metadataBar = document.getElementById('session-metadata-compact');

        if (!isProxyActive()) {
          sidebar.style.display = 'none';
          metadataBar.style.display = 'none';
          return;
        }

        sidebar.style.display = 'flex';
        metadataBar.style.display = 'flex';

        // Show/hide search input based on number of connections
        const searchContainer = document.getElementById('connection-search');
        if (connections.length > 3 && !sidebar.classList.contains('collapsed')) {
          searchContainer.style.display = 'block';
        } else {
          searchContainer.style.display = 'none';
        }

        // Update "All Connections" item
        const allItem = document.getElementById('connection-item-all');
        const totalFrames = connections.reduce((sum, c) => sum + c.frameCount, 0);
        allItem.querySelector('.frame-count').textContent = `(${totalFrames})`;
        allItem.className = `connection-item all ${selectedConnectionId === null ? 'active' : ''}`;
        allItem.setAttribute('aria-selected', selectedConnectionId === null ? 'true' : 'false');

        // Separate active and recent connections
        const activeConnections = connections.filter(c => c.active);
        const recentConnections = connections.filter(c => !c.active);

        // Update group visibility and counts
        updateConnectionGroup('active-connections-group', activeConnections, 'active-group-count');
        updateConnectionGroup('recent-connections-group', recentConnections, 'recent-group-count');

        // Populate connection lists
        populateConnectionList('active-connections-list', activeConnections);
        populateConnectionList('recent-connections-list', recentConnections);

        // Update connection count in metadata bar
        const connectionCountEl = document.getElementById('connection-count');
        connectionCountEl.textContent = activeConnections.length;

        // Update session metadata
        updateSessionMetadata();
      }

      function updateConnectionGroup(groupId, connections, countId) {
        const group = document.getElementById(groupId);
        const countEl = document.getElementById(countId);

        if (connections.length > 0) {
          group.style.display = 'block';
          countEl.textContent = `(${connections.length})`;
        } else {
          group.style.display = 'none';
        }
      }

      function populateConnectionList(listId, connections) {
        const list = document.getElementById(listId);
        list.innerHTML = '';

        connections.forEach(conn => {
          const item = createConnectionCard(conn);
          list.appendChild(item);
        });
      }

      function createConnectionCard(conn) {
        const item = document.createElement('button');
        item.role = 'tab';
        item.id = `connection-item-${conn.connectionId}`;
        item.className = `connection-item ${selectedConnectionId === conn.connectionId ? 'active' : ''} ${conn.active ? '' : 'closed'}`;
        item.dataset.connectionId = conn.connectionId;
        item.dataset.port = conn.sourcePort;
        item.setAttribute('aria-selected', selectedConnectionId === conn.connectionId ? 'true' : 'false');
        item.setAttribute('aria-controls', 'timeline-proxy');
        item.tabIndex = selectedConnectionId === conn.connectionId ? 0 : -1;

        // Generate smart label and duration
        const smartLabel = generateSmartLabel(conn, connections);
        const duration = formatDuration(conn.durationSeconds);
        const startTime = new Date(conn.startTime).toLocaleTimeString();

        item.innerHTML = `
          <div class="port-indicator" data-port="${conn.sourcePort}"></div>
          <div class="connection-info">
            <span class="connection-name">${smartLabel}</span>
            <div class="connection-meta">
              <span class="frame-count">${conn.frameCount} frames</span>
              <span class="connection-duration">${duration}</span>
              <span class="start-time">${startTime}</span>
            </div>
          </div>
          <div class="connection-status ${conn.active ? 'active' : 'closed'}"></div>
        `;

        // Add click handler
        item.addEventListener('click', () => selectConnection(conn.connectionId));

        // Add hover tooltip
        item.title = `${conn.sourceIp}:${conn.sourcePort}\nStarted: ${startTime}\nDuration: ${duration}\nFrames: ${conn.frameCount}\nStatus: ${conn.active ? 'Active' : 'Closed'}`;

        return item;
      }

      function selectConnection(connectionId) {
        selectedConnectionId = connectionId;

        // Update ARIA labelledby for the timeline panel
        const timelinePanel = document.getElementById('timeline-proxy');
        const activeItemId = connectionId ? `connection-item-${connectionId}` : 'connection-item-all';
        timelinePanel.setAttribute('aria-labelledby', activeItemId);

        // Make announcement for screen readers
        const announcer = document.getElementById('connection-announcer');
        let announcement;
        if (connectionId) {
          const conn = connections.find(c => c.connectionId === connectionId);
          const connLabel = conn ? `${conn.sourceIp}:${conn.sourcePort}` : 'unknown connection';
          announcement = `Switched to connection ${connLabel}`;
        } else {
          announcement = 'Showing all connections';
        }
        announcer.textContent = announcement;

        updateConnectionsSidebar();
        filterFramesByConnection();
      }

      function filterFramesByConnection() {
        if (!isProxyActive()) return;

        const timeline = document.getElementById('timeline-proxy');
        const frames = timeline.children;

        for (const frame of frames) {
          if (selectedConnectionId === null) {
            // Show all frames
            frame.style.display = '';
          } else {
            // Check if frame belongs to selected connection
            const frameConnectionId = frame.dataset.connectionId;
            if (frameConnectionId === selectedConnectionId) {
              frame.style.display = '';
            } else {
              frame.style.display = 'none';
            }
          }
        }
      }

      function formatDuration(seconds) {
        if (seconds < 60) return `${seconds}s`;
        const minutes = Math.floor(seconds / 60);
        if (minutes < 60) return `${minutes}m`;
        const hours = Math.floor(minutes / 60);
        return `${hours}h${minutes % 60}m`;
      }

      function showConnectionTooltip(element, conn) {
        // Create tooltip showing connection details
        const tooltip = document.createElement('div');
        tooltip.className = 'popover';
        tooltip.style.display = 'block';
        tooltip.style.top = '50%';
        tooltip.style.transform = 'translateY(-50%)';
        tooltip.innerHTML = `
          <div><strong>Connection ${conn.connectionId}</strong></div>
          <div>IP: ${conn.sourceIp}:${conn.sourcePort}</div>
          <div>Started: ${new Date(conn.startTime).toLocaleString()}</div>
          <div>Duration: ${formatDuration(conn.durationSeconds)}</div>
          <div>Total Frames: ${conn.frameCount}</div>
          <div>Status: ${conn.active ? 'Active' : 'Closed'}</div>
        `;
        element.style.position = 'relative';
        element.appendChild(tooltip);
      }

      function hideConnectionTooltip() {
        document.querySelectorAll('.connection-item .popover').forEach(tooltip => {
          tooltip.remove();
        });
      }

      async function loadConnections() {
        if (!proxyRunning) {
          connections = [];
          updateConnectionsSidebar();
          return;
        }

        try {
          const res = await fetch('/api/connections');
          if (res.ok) {
            const data = await res.json();
            connections = data.connections || [];
            updateConnectionsSidebar();
          }
        } catch (e) {
          console.warn('Failed to load connections:', e);
        }
      }

      function handleConnectionEvent(data) {
        if (data.event === 'connection_opened') {
          // Add new connection
          const newConnection = {
            connectionId: data.connectionId,
            sourceIp: data.sourceIp,
            sourcePort: data.sourcePort,
            startTime: new Date().toISOString(),
            frameCount: 0,
            active: true,
            durationSeconds: 0
          };
          connections.push(newConnection);
          updateConnectionsSidebar();
        } else if (data.event === 'connection_closed') {
          // Mark connection as closed and schedule auto-cleanup
          const conn = connections.find(c => c.connectionId === data.connectionId);
          if (conn) {
            conn.active = false;
            conn.frameCount = data.frameCount || conn.frameCount;
            conn.closedTime = new Date().toISOString();

            // Schedule auto-cleanup after 10 minutes
            setTimeout(() => {
              cleanupClosedConnection(conn.connectionId);
            }, 10 * 60 * 1000); // 10 minutes

            updateConnectionsSidebar();
          }
        } else if (data.event === 'connections_reset') {
          // Clear all connections
          connections = [];
          selectedConnectionId = null;
          updateConnectionsSidebar();
        }
      }

      function cleanupClosedConnection(connectionId) {
        const index = connections.findIndex(c => c.connectionId === connectionId);
        if (index !== -1 && !connections[index].active) {
          // If this was the selected connection, switch to "All Connections"
          if (selectedConnectionId === connectionId) {
            selectConnection(null);
          }

          connections.splice(index, 1);
          updateConnectionsSidebar();

          // Show a subtle notification
          showToast(`Cleaned up closed connection`, 'info');
        }
      }

      function clearAllClosedConnections() {
        const activeConnections = connections.filter(c => c.active);
        const removedCount = connections.length - activeConnections.length;

        if (removedCount > 0) {
          // If selected connection was closed, switch to "All Connections"
          if (selectedConnectionId && !connections.find(c => c.connectionId === selectedConnectionId && c.active)) {
            selectConnection(null);
          }

          connections = activeConnections;
          updateConnectionsSidebar();
          showToast(`Cleared ${removedCount} closed connection(s)`, 'success');
        }
      }

      async function loadJsonlFile(file) {
        // reset UI
        document.getElementById('timeline-pcap').innerHTML = '';
        activeFrames().length = 0;
        firstPcapFrameTs = null;

        const reader = new FileReader();
        reader.onload = async (e) => {
          const content = e.target.result;

          // Parse and render frames
          const lines = content.split('\n');
          let lineCount = 0;

          for (const line of lines) {
            if (!line.trim()) continue;
            try {
              const obj = JSON.parse(line);
              activeFrames().push({ obj, raw: line });
              renderFrame(obj, line, document.getElementById('timeline-pcap'));
              lineCount++;
            } catch (e) {
              console.warn('Failed to parse JSON line:', line, e);
            }
          }

          document.getElementById('file-type-indicator').textContent = '• JSONL File';
        };

        reader.onerror = () => {
        };

        reader.readAsText(file);
      }

      function setFile(file) {
        selectedFile = file;
        if (file) {
          const fileName = file.name;
          const fileExt = fileName.toLowerCase().split('.').pop();
          const isJsonl = fileExt === 'jsonl';
          const isPcap = fileExt === 'pcap';

          // Update UI based on file type
          if (isJsonl) {
            dz.querySelector('.dz-title').textContent = `JSONL: ${fileName}`;
            loadJsonlFile(file);
          } else if (isPcap) {
            dz.querySelector('.dz-title').textContent = `PCAP: ${fileName}`;
            startUpload();
          } else {
            dz.querySelector('.dz-title').textContent = `File: ${fileName}`;
            return;
          }
        } else {
          dz.querySelector('.dz-title').textContent = 'Drop a PCAP or JSONL file here';
        }
      }
      

      dz.addEventListener('click', () => fileInput.click());
      fileInput.addEventListener('change', () => setFile(fileInput.files[0]))

      dz.addEventListener('dragover', (e) => { e.preventDefault(); dz.classList.add('dragover'); });
      dz.addEventListener('dragleave', () => dz.classList.remove('dragover'));
      dz.addEventListener('drop', (e) => {
        e.preventDefault(); dz.classList.remove('dragover');
        if (e.dataTransfer.files && e.dataTransfer.files[0]) setFile(e.dataTransfer.files[0]);
      });

      // Sidebar event handlers
      document.getElementById('sidebar-toggle').addEventListener('click', toggleSidebar);
      document.getElementById('clear-recent-btn-sidebar').addEventListener('click', clearAllClosedConnections);
      document.getElementById('connection-item-all').addEventListener('click', () => selectConnection(null));
      document.getElementById('search-connections').addEventListener('input', handleConnectionSearch);

      function toggleSidebar() {
        const sidebar = document.getElementById('connections-sidebar');
        sidebar.classList.toggle('collapsed');

        // Show/hide search when expanding
        const searchContainer = document.getElementById('connection-search');
        if (sidebar.classList.contains('collapsed')) {
          searchContainer.style.display = 'none';
        } else if (connections.length > 3) {
          searchContainer.style.display = 'block';
        }
      }

      function handleConnectionSearch(e) {
        const query = e.target.value.toLowerCase();
        const activeList = document.getElementById('active-connections-list');
        const recentList = document.getElementById('recent-connections-list');

        filterConnectionItems(activeList, query);
        filterConnectionItems(recentList, query);
      }

      function filterConnectionItems(container, query) {
        const items = container.querySelectorAll('.connection-item');
        items.forEach(item => {
          const name = item.querySelector('.connection-name').textContent.toLowerCase();
          const meta = item.querySelector('.connection-meta').textContent.toLowerCase();

          if (name.includes(query) || meta.includes(query)) {
            item.style.display = 'flex';
          } else {
            item.style.display = 'none';
          }
        });
      }

      function syntaxHighlight(json) {
        // escape HTML
        json = json.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
        // keys
        json = json.replace(/\"(\\.|[^"\\])*\"(?=\s*:)/g, (m) => `<span class="hl-key">${m}</span>`);
        // strings
        json = json.replace(/\"(\\.|[^"\\])*\"(?!\s*:)/g, (m) => `<span class="hl-string">${m}</span>`);
        // numbers
        json = json.replace(/\b-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?\b/g, (m) => `<span class="hl-number">${m}</span>`);
        // booleans
        json = json.replace(/\b(?:true|false)\b/g, (m) => `<span class="hl-boolean">${m}</span>`);
        // null
        json = json.replace(/\bnull\b/g, '<span class="hl-null">null</span>');
        return json;
      }

      function formatTimestamp(ts) {
        if (!ts) return '';
        const seconds = parseFloat(ts);
        const date = new Date(seconds * 1000);
        const h = date.getUTCHours().toString().padStart(2, '0');
        const m = date.getUTCMinutes().toString().padStart(2, '0');
        const s = date.getUTCSeconds().toString().padStart(2, '0');
        const ms = date.getUTCMilliseconds().toString().padStart(3, '0');
        return `${h}:${m}:${s}.${ms}`;
      }

      function parseTimestampValue(ts) {
        if (ts === undefined || ts === null) return null;
        if (typeof ts === 'number') return ts;
        if (typeof ts === 'string') {
          const numeric = Number(ts);
          if (!Number.isNaN(numeric)) return numeric;
          const timeMatch = ts.match(/^(\\d{2}):(\\d{2}):(\\d{2})(?:\\.(\\d+))?$/);
          if (timeMatch) {
            const [, hh, mm, ss, frac] = timeMatch;
            const base = parseInt(hh, 10) * 3600 + parseInt(mm, 10) * 60 + parseInt(ss, 10);
            const fraction = frac ? parseFloat(`0.${frac}`) : 0;
            return base + fraction;
          }
        }
        return null;
      }

      function extractStreamIdFromHex(obj, format = 'hex') {
        let raw = obj.streamId ?? null;

        // Fallback: Extract from fullHex for backward compatibility with old JSONL files
        if (!raw && obj.fullHex && obj.fullHex.length >= 24) {
          const hex = obj.fullHex.replace(/\s/g, '');
          if (hex.length >= 24) {
            raw = '0x' + hex.substring(20, 24);
          }
        }

        if (raw === null || raw === undefined) return null;

        // Normalize to numeric value when possible
        let numeric = null;
        if (typeof raw === 'number') {
          numeric = raw;
        } else if (typeof raw === 'string') {
          if (raw.startsWith('0x') || raw.startsWith('0X')) {
            numeric = parseInt(raw, 16);
          } else {
            const parsed = Number(raw);
            numeric = Number.isNaN(parsed) ? null : parsed;
          }
        }

        if (numeric === null || Number.isNaN(numeric)) {
          // Fall back to raw string if parsing failed
          return format === 'dec' ? raw : raw.toString();
        }

        if (format === 'dec') {
          return numeric.toString();
        }

        return '0x' + numeric.toString(16).padStart(4, '0');
      }

      function formatHex(hex) {
        if (!hex) return '';
        const bytes = hex.replace(/\s+/g,'').match(/.{1,2}/g) || [];
        let out = '';
        for (let i = 0; i < bytes.length; i += 16) {
          const line = bytes.slice(i, i + 16);
          let hexPart = '';
          let ascii = '';
          for (let j = 0; j < line.length; j++) {
            const b = parseInt(line[j], 16);
            hexPart += line[j] + ' ';
            if (j === 7) hexPart += ' ';
            ascii += (b >= 32 && b < 127) ? String.fromCharCode(b) : '.';
          }
          const missing = 16 - line.length;
          const padSpaces = missing * 3 + (line.length <= 8 ? 1 : 0);
          hexPart += ' '.repeat(padSpaces);
          out += hexPart + ' |' + ascii + '|\n';
        }
        return out.trimEnd();
      }

      // Format hex with individual byte spans for hover highlighting
      function formatHexWithSpans(hex) {
        if (!hex) return '';
        const bytes = hex.replace(/\s+/g,'').match(/.{1,2}/g) || [];
        let out = '';
        for (let i = 0; i < bytes.length; i += 16) {
          const line = bytes.slice(i, i + 16);
          let hexPart = '';
          let ascii = '';
          for (let j = 0; j < line.length; j++) {
            const byteIdx = i + j;
            const b = parseInt(line[j], 16);
            hexPart += `<span class="hex-byte" data-byte="${byteIdx}">${line[j]}</span> `;
            if (j === 7) hexPart += ' ';
            const ch = (b >= 32 && b < 127) ? String.fromCharCode(b) : '.';
            ascii += `<span class="hex-byte" data-byte="${byteIdx}">${ch.replace(/</g,'&lt;').replace(/>/g,'&gt;')}</span>`;
          }
          const missing = 16 - line.length;
          const padSpaces = missing * 3 + (line.length <= 8 ? 1 : 0);
          hexPart += ' '.repeat(padSpaces);
          out += hexPart + ' |' + ascii + '|\n';
        }
        return out.trimEnd();
      }

      // Highlight specific byte range in hex view
      function highlightBytes(frameEl, start, end) {
        const hexEl = frameEl.querySelector('.hex');
        if (!hexEl) return;
        if (!Number.isFinite(start) || !Number.isFinite(end)) return;
        if (end < start) return;
        const safeStart = Math.max(0, start);
        for (let i = safeStart; i <= end; i++) {
          hexEl.querySelectorAll(`[data-byte="${i}"]`).forEach(el => {
            el.classList.add('hex-byte-hover');
          });
        }
      }

      // Clear all byte highlights in a frame
      function clearByteHighlights(frameEl) {
        const hexEl = frameEl.querySelector('.hex');
        if (!hexEl) return;
        hexEl.querySelectorAll('.hex-byte-hover').forEach(el => {
          el.classList.remove('hex-byte-hover');
        });
      }

      function renderFrame(obj, raw, container) {
        // Update session metadata - count all frames in proxy timeline
        if (container.id === 'timeline-proxy') {
          totalFramesReceived++;

          // Track sequence numbers for gap detection
          if (obj.seq !== undefined) {
            if (lastSequenceNumber !== null) {
              const expectedSeq = lastSequenceNumber + 1;
              if (obj.seq > expectedSeq) {
                sequenceGaps += (obj.seq - expectedSeq);
              }
            }
            lastSequenceNumber = obj.seq;
          }

          updateSessionMetadata();
        }

        const el = document.createElement('div');
        el.className = 'frame ' + (obj.dir === 'S->C' ? 's2c' : 'c2s');

        // Add connection ID data attribute for filtering
        if (obj.connectionId) {
          el.dataset.connectionId = obj.connectionId;
        }

        // Direction styling - subtle left border hint
        const dirPillClass = obj.dir === 'S->C' ? 'dir-s2c' : 'dir-c2s';
        const dirLabel = obj.dir === 'S->C' ? 'S→C' : 'C→S';

        // CRC handling - only show indicator on error
        const hasCrcField = Object.prototype.hasOwnProperty.call(obj, 'crcOk');
        const crcOk = hasCrcField ? !!obj.crcOk : true;
        const crcPill = (!hasCrcField || crcOk) ? '' : `<span class="pill pill-crc">!</span>`;

        // P3 packet type handling
        const baseTypeName = obj.typeName || obj.type || '?';
        const typeClass = obj.typeName ? `type-${obj.typeName.toLowerCase()}` : 'type-unknown';
        const isDataPacket = obj.typeName === 'DATA';
        const isNakPacket = obj.typeName === 'NAK';

        let typeDisplay = baseTypeName;
        if (isNakPacket && obj.nakReason) {
          const shortReason = obj.nakReason
            .replace('_ERROR', '')
            .replace('_', ' ')
            .toLowerCase()
            .replace(/\b\w/g, c => c.toUpperCase());
          typeDisplay = `NAK (${shortReason})`;
        }

        // Type hover range: highlight payload bytes for DATA, type byte otherwise
        let typeHoverStart = 7;
        let typeHoverEnd = 7;
        const lenNumber = Number(obj.len);
        const hasLenValue = Number.isFinite(lenNumber);

        // Token pill - only for DATA packets with token
        // Byte range: offset 8-9 (after 8-byte header)
        let tokenPill = '';
        if (isDataPacket && obj.token) {
          tokenPill = `<span class="pill pill-token pill-hoverable" data-byte-start="8" data-byte-end="9"><span class="pill-label">token</span>: <span class="pill-value">${obj.token}</span></span>`;
        }

        // Stream ID pill - only for DATA packets with streamId
        // Byte range: offset 10-11 (after token)
        let streamIdPill = '';
        const streamIdHex = isDataPacket ? extractStreamIdFromHex(obj, 'hex') : null;
        const streamIdDecimal = isDataPacket ? extractStreamIdFromHex(obj, 'dec') : null;
        if (streamIdHex && streamIdDecimal !== null) {
          streamIdPill = `<span class="pill pill-sid pill-hoverable"
                    data-stream-id="${streamIdDecimal}"
                    data-byte-start="10"
                    data-byte-end="11"
                    role="button"
                    tabindex="0"><span class="pill-label">sid</span>: <span class="pill-value">${streamIdDecimal}</span></span>`;
        }

        // Relative timestamp from frame's actual timestamp
        // Use the earliest timestamp seen for current dataset
        const parsedTs = parseTimestampValue(obj.ts);
        const frameTs = parsedTs !== null ? parsedTs : Date.now() / 1000;
        const isProxy = container.id === 'timeline-proxy';
        if (isProxy) {
          if (firstProxyFrameTs === null || frameTs < firstProxyFrameTs) firstProxyFrameTs = frameTs;
        } else {
          if (firstPcapFrameTs === null || frameTs < firstPcapFrameTs) firstPcapFrameTs = frameTs;
        }
        const firstTs = isProxy ? firstProxyFrameTs : firstPcapFrameTs;
        const relSecs = firstTs !== null ? Math.max(0, frameTs - firstTs) : 0;
        const formattedTs = formatTimestamp(obj.ts);
        // Format: show 1 decimal for < 100s, whole seconds otherwise
        const timeDisplay = relSecs < 100 ? `+${relSecs.toFixed(1)}s` : `+${Math.round(relSecs)}s`;

        const dirPillHtml = `<span class="pill pill-dir ${dirPillClass}"><span class="pill-label">dir</span>: <span class="pill-value">${dirLabel}</span></span>`;
        const typePillHtml = `<span class="pill pill-type type-pill ${typeClass} pill-hoverable" data-byte-start="${typeHoverStart}" data-byte-end="${typeHoverEnd}"><span class="pill-label">type</span>: <span class="pill-value">${typeDisplay}</span></span>`;
        const lenDisplay = hasLenValue ? lenNumber.toString() : '—';
        const lenPillHtml = `<span class="pill pill-len pill-hoverable" data-byte-start="3" data-byte-end="4"><span class="pill-label">len</span>: <span class="pill-value">${lenDisplay}</span></span>`;
        const txValue = (obj.tx !== undefined && obj.tx !== null) ? obj.tx : '—';
        const rxValue = (obj.rx !== undefined && obj.rx !== null) ? obj.rx : '—';
        const txPillHtml = `<span class="pill pill-seq pill-hoverable" data-byte-start="5" data-byte-end="5"><span class="pill-label">tx</span>: <span class="pill-value">${txValue}</span></span>`;
        const rxPillHtml = `<span class="pill pill-seq pill-hoverable" data-byte-start="6" data-byte-end="6"><span class="pill-label">rx</span>: <span class="pill-value">${rxValue}</span></span>`;
        const timePillHtml = `<span class="pill pill-time"><span class="pill-label">dt</span>: <span class="pill-value">${timeDisplay}</span></span>`;
        const tokenPillHtml = tokenPill || `<span class="pill pill-token pill-muted"><span class="pill-label">token</span>: <span class="pill-value">—</span></span>`;
        const streamIdPillHtml = streamIdPill || `<span class="pill pill-sid pill-muted"><span class="pill-label">sid</span>: <span class="pill-value">—</span></span>`;

        el.innerHTML = `
          <div class="meta">
            <div class="meta-fields">
              ${dirPillHtml}
              ${typePillHtml}
              ${crcPill}
              ${lenPillHtml}
              ${txPillHtml}
              ${rxPillHtml}
              ${tokenPillHtml}
              ${streamIdPillHtml}
              ${timePillHtml}
            </div>
            <span class="actions">
              <button class="iconbtn" data-act="copy-json">JSON</button>
              <button class="iconbtn" data-act="copy-hex">Hex</button>
              <button class="iconbtn" data-act="show-fdo">FDO</button>
            </span>
          </div>
          ${obj.fullHex ? `<div class="hex" data-full-hex="${obj.fullHex}"></div>` : ''}
        `;

        // Render hex with individual byte spans for highlighting
        if (obj.fullHex) {
          const hexEl = el.querySelector('.hex');
          if (hexEl) {
            hexEl.innerHTML = formatHexWithSpans(obj.fullHex);
          }
        }

        // Add hover handlers for byte highlighting
        el.querySelectorAll('.pill-hoverable').forEach(pill => {
          const start = parseInt(pill.dataset.byteStart, 10);
          const end = parseInt(pill.dataset.byteEnd, 10);
          if (!isNaN(start) && !isNaN(end)) {
            pill.addEventListener('mouseenter', () => highlightBytes(el, start, end));
            pill.addEventListener('mouseleave', () => clearByteHighlights(el));
          }
        });
        // Highlight payload when hovering FDO button
        const fdoBtn = el.querySelector('[data-act="show-fdo"]');
        if (fdoBtn) {
          const payloadLen = (hasLenValue && lenNumber > 3) ? Math.max(0, lenNumber - 3) : 0;
          const fdoStart = 12; // skip token (2) + streamId (2) after header
          const fdoEnd = payloadLen > 4 ? fdoStart + (payloadLen - 4) - 1 : fdoStart - 1;
          if (fdoEnd >= fdoStart) {
            fdoBtn.addEventListener('mouseenter', () => highlightBytes(el, fdoStart, fdoEnd));
            fdoBtn.addEventListener('mouseleave', () => clearByteHighlights(el));
          }
        }
        el.addEventListener('click', async (e) => {
          const target = e.target.closest('[data-act]');
          if (!target) return;
          const act = target.getAttribute('data-act');
          if (act === 'copy-json') {
            const pretty = JSON.stringify(obj, null, 2);
            await navigator.clipboard.writeText(pretty);
            if (target.tagName === 'BUTTON') { target.textContent = 'Copied'; setTimeout(() => target.textContent = 'JSON', 800); }
          } else if (act === 'copy-hex') {
            await navigator.clipboard.writeText(obj.fullHex || '');
            if (target.tagName === 'BUTTON') { target.textContent = 'Copied'; setTimeout(() => target.textContent = 'Hex', 800); }
          } else if (act === 'show-fdo') {
            // If already decompiled, show it immediately
            if (obj.fdoSource) {
              showFdoModal(obj.fdoSource);
            } else {
              // Otherwise, decompile on demand
              if (!obj.fullHex) {
                toast('No frame data available for decompilation', 'err');
                return;
              }

              // Show loading state
              target.disabled = true;
              target.textContent = 'Decompiling...';

              fetch('/api/decompile-frame', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ fullHex: obj.fullHex })
              })
              .then(res => res.json())
              .then(result => {
                target.disabled = false;
                target.textContent = 'FDO';

                if (result.success && result.fdoSource) {
                  // Unescape newlines and other escape sequences from JSON
                  const unescapedSource = result.fdoSource
                    .replace(/\\n/g, '\n')
                    .replace(/\\r/g, '\r')
                    .replace(/\\t/g, '\t');

                  // Cache the unescaped result in the frame object
                  obj.fdoSource = unescapedSource;
                  showFdoModal(unescapedSource);
                } else {
                  toast(result.error || 'Decompilation failed', 'err');
                }
              })
              .catch(err => {
                target.disabled = false;
                target.textContent = 'FDO';
                toast('Failed to decompile: ' + err.message, 'err');
              });
            }
          }
        });
        const targetContainer = container || (isProxyActive() ? document.getElementById('timeline-proxy') : document.getElementById('timeline-pcap'));
        targetContainer.prepend(el);
      }


      function rerenderAll() {
        document.getElementById('timeline-pcap').innerHTML = '';
        document.getElementById('timeline-proxy').innerHTML = '';
        const renderList = (arr, containerId) => {
          const container = document.getElementById(containerId);
          for (const f of arr) {
            renderFrame(f.obj, f.raw, container);
          }
        };
        renderList(framesPcap, 'timeline-pcap');
        renderList(framesProxy, 'timeline-proxy');
      }


      clearBtn.addEventListener('click', () => {
        activeFrames().length = 0;
        rerenderAll();
        document.getElementById('file-type-indicator').textContent = '';
        // Reset dropzone title
        dz.querySelector('.dz-title').textContent = 'Drop a PCAP or JSONL file here';
        // Reset selected file
        selectedFile = null;
        // Reset first frame timestamps for relative time
        firstPcapFrameTs = null;
        firstProxyFrameTs = null;
      });


      // Update proxy status and UI
      async function updateProxyStatus() {
        try {
          const response = await fetch('/api/proxy/status');
          const status = await response.json();

          const statusDot = document.getElementById('proxy-status-dot');

          if (status.running) {
            if (statusDot) statusDot.classList.add('running');

            // Update global proxy state
            proxyRunning = true;

            // Load connections and start live streaming
            await loadConnections();
            startLive();
          } else {
            if (statusDot) statusDot.classList.remove('running');

            // Update global proxy state
            proxyRunning = false;

            // Stop live streaming
            if (window.es) {
              window.es.close();
              window.es = null;
            }
          }
        } catch (err) {
          console.error('Error checking proxy status:', err);
        }
      }

      async function startLive(){
        if (window.es) return; // Already connected
        console.log('Connecting to live stream...');
        window.es = new EventSource('/api/live');
        window.es.onopen = () => {
          console.log('Live stream connected successfully');
          toast('Live session active','ok');

          // Initialize session metadata
          // Only reset if no frames have been counted yet (avoid resetting when reopening with historical frames)
          if (totalFramesReceived === 0) {
            sessionStartTime = Date.now();
            lastSequenceNumber = null;
            sequenceGaps = 0;
            firstProxyFrameTs = null;
          } else {
            // Preserve existing session start time and metadata when reconnecting
          }
          updateSessionMetadata();

          // Only switch to proxy tab if user hasn't explicitly navigated elsewhere
          const currentHash = window.location.hash.substring(1);
          const cleanHash = currentHash.startsWith('/') ? currentHash.substring(1) : currentHash;
          // Don't override user's explicit navigation to PCAP tab
          if (cleanHash !== 'pcap') {
            const proxyTab = document.querySelector('[data-tab="proxy"]');
            if (proxyTab && !proxyTab.classList.contains('active')) {
              proxyTab.click();
            }
          }
        };
        window.es.onmessage = (ev) => {
          try {
            const obj = JSON.parse(ev.data);

            // Handle connection lifecycle events
            if (obj.event) {
              console.log('Received connection event:', obj.event);
              handleConnectionEvent(obj);

              // Update connection frame counts for existing connections
              if (obj.connectionId) {
                const conn = connections.find(c => c.connectionId === obj.connectionId);
                if (conn && obj.event !== 'connection_opened' && obj.event !== 'connection_closed') {
                  conn.frameCount = (conn.frameCount || 0) + 1;
                  updateConnectionsSidebar();
                }
              }
              return;
            }

            // Handle frame data
            console.log('Received live frame:', ev.data);
            const frameData = { obj, raw: ev.data, isLive: true };
            activeFrames().push(frameData);
            renderFrame(obj, ev.data, document.getElementById('timeline-proxy'));

            // Update connection frame count if this frame has a connectionId
            if (obj.connectionId) {
              const conn = connections.find(c => c.connectionId === obj.connectionId);
              if (conn) {
                conn.frameCount = (conn.frameCount || 0) + 1;
                updateConnectionsSidebar();
              }
            }

          } catch (e) {
            console.error('Failed to parse live data:', e, ev.data);
          }
        };
        window.es.onerror = (e) => {
          console.error('Live stream error:', e);
          if (window.es) window.es.close();
          window.es = null;
          toast('Live session inactive','err');

          // Auto-reconnect if proxy is still running
          if (proxyRunning) {
            console.log('Attempting to reconnect live stream in 3 seconds...');
            setTimeout(() => {
              if (proxyRunning && !window.es) {
                console.log('Reconnecting live stream...');
                startLive();
              }
            }, 3000);
          }
        };
      }
      function stopLive(){
        if (window.es){
          window.es.close();
          window.es = null;
        }

        // Reset session metadata
        activeConnections = 0;
        updateSessionMetadata();
      }

      // Stream Rail functions - visual connector for stream selection
      function getActiveTimeline() {
        const activeTab = document.querySelector('.tab.active');
        if (activeTab && activeTab.dataset.tab === 'proxy') {
          return document.getElementById('timeline-proxy');
        }
        return document.getElementById('timeline-pcap');
      }

      function createStreamRail(streamId, matchingPills) {
        removeStreamRail();

        const timeline = getActiveTimeline();
        if (!timeline || matchingPills.length === 0) return;

        timeline.classList.add('has-stream-selection');

        // Create rail container
        const rail = document.createElement('div');
        rail.className = 'stream-rail';
        rail.id = 'stream-rail';

        // Get frame positions relative to timeline
        const timelineRect = timeline.getBoundingClientRect();
        const positions = [];

        matchingPills.forEach(pill => {
          const frame = pill.closest('.frame');
          if (frame) {
            const frameRect = frame.getBoundingClientRect();
            const relativeTop = frameRect.top - timelineRect.top + timeline.scrollTop;
            positions.push(relativeTop + frameRect.height / 2);
          }
        });

        if (positions.length > 0) {
          // Vertical line spanning from first to last frame
          const minY = Math.min(...positions);
          const maxY = Math.max(...positions);
          const line = document.createElement('div');
          line.className = 'stream-rail-line';
          line.style.top = minY + 'px';
          line.style.height = (maxY - minY) + 'px';
          rail.appendChild(line);

          // Connection nodes at each matching frame
          positions.forEach(y => {
            const node = document.createElement('div');
            node.className = 'stream-rail-node';
            node.style.top = y + 'px';
            rail.appendChild(node);
          });
        }

        // Fixed action button (appended to body so it's not clipped)
        const btn = document.createElement('button');
        btn.className = 'stream-rail-action';
        btn.id = 'stream-rail-action';
        btn.title = 'Decompile selected stream';
        btn.innerHTML = `
          <span class="stream-rail-action-icon">&#x2699;</span>
          <span class="stream-rail-action-count">${matchingPills.length}</span>
        `;
        btn.addEventListener('click', handleDecompileStream);
        document.body.appendChild(btn);

        // Ensure timeline has relative positioning for absolute children
        timeline.style.position = 'relative';
        timeline.insertBefore(rail, timeline.firstChild);
      }

      function removeStreamRail() {
        const rail = document.getElementById('stream-rail');
        if (rail) rail.remove();

        const btn = document.getElementById('stream-rail-action');
        if (btn) btn.remove();

        document.querySelectorAll('.timeline').forEach(t => {
          t.classList.remove('has-stream-selection');
        });
      }

      // StreamId filtering functions
      function highlightStream(streamId) {
        // Clear any existing highlights and hover previews
        clearStreamHighlight();
        clearHoverPreview();

        // Set new active stream
        activeStreamId = streamId;

        // Find all pills with matching streamId
        const allPills = document.querySelectorAll(`[data-stream-id="${streamId}"]`);
        const matchCount = allPills.length;

        if (matchCount === 0) return;

        // Highlight pills and their parent frames
        allPills.forEach((pill, index) => {
          // First pill gets selected state, others get highlighted state
          if (index === 0) {
            pill.classList.add('stream-selected');
          } else {
            pill.classList.add('stream-highlighted');
          }
          // Also highlight the parent frame row
          const frameEl = pill.closest('.frame');
          if (frameEl) {
            frameEl.classList.add('frame-stream-selected');
          }
        });

        // Show and update the "Decompile Stream" button in header
        const decompileStreamBtn = getDecompileStreamButton();
        if (decompileStreamBtn) {
          const plural = matchCount !== 1 ? 's' : '';
          decompileStreamBtn.textContent = `Decompile Stream (${matchCount} frame${plural})`;
          decompileStreamBtn.style.display = '';
        }

        // Create the stream rail visual connector
        createStreamRail(streamId, Array.from(allPills));

        // Show toast notification
        const plural = matchCount !== 1 ? 's' : '';
        toast(`Highlighting ${matchCount} frame${plural} with streamId: ${streamId}`, 'ok');
      }

      function clearStreamHighlight() {
        if (!activeStreamId) return;

        // Remove all highlight classes from pills and frames
        document.querySelectorAll('.stream-selected, .stream-highlighted')
          .forEach(el => el.classList.remove('stream-selected', 'stream-highlighted'));
        document.querySelectorAll('.frame-stream-selected')
          .forEach(el => el.classList.remove('frame-stream-selected'));
        clearHoverPreview();

        // Hide both "Decompile Stream" buttons in headers
        const proxyBtn = document.getElementById('decompile-stream-proxy');
        const pcapBtn = document.getElementById('decompile-stream-pcap');
        if (proxyBtn) proxyBtn.style.display = 'none';
        if (pcapBtn) pcapBtn.style.display = 'none';

        // Remove the stream rail
        removeStreamRail();

        // Reset state
        activeStreamId = null;
      }


      function showHoverPreview(streamId) {
        // Don't show hover preview if this streamId is already selected
        if (activeStreamId === streamId) return;

        // Clear any existing hover previews
        clearHoverPreview();

        // Find all pills with this streamId and add hover preview class
        const allPills = document.querySelectorAll(`[data-stream-id="${streamId}"]`);
        allPills.forEach(pill => {
          // Don't add hover class to selected pills
          if (!pill.classList.contains('stream-selected')) {
            pill.classList.add('stream-hover-preview');
          }
        });
      }

      function clearHoverPreview() {
        // Remove hover preview class from all pills
        document.querySelectorAll('.stream-hover-preview')
          .forEach(el => el.classList.remove('stream-hover-preview'));
      }

      function initStreamIdFiltering() {
        // Click handler for streamId pills
        document.addEventListener('click', (e) => {
          const pill = e.target.closest('.pill-sid[data-stream-id]');

          if (!pill) {
            // Check if clicking outside - clear selection
            if (activeStreamId && !e.target.closest('.frame')) {
              clearStreamHighlight();
            }
            return;
          }

          const streamId = pill.dataset.streamId;
          if (!streamId || streamId === 'null') return;

          // Toggle selection
          if (activeStreamId === streamId) {
            clearStreamHighlight();
          } else {
            highlightStream(streamId);
          }
        });

        // Hover preview handler
        document.addEventListener('mouseover', (e) => {
          const pill = e.target.closest('.pill-sid[data-stream-id]');
          if (!pill) return;

          const streamId = pill.dataset.streamId;
          if (!streamId || streamId === 'null') return;

          // Show hover preview for this streamId
          showHoverPreview(streamId);
        });

        // Clear hover preview when mouse leaves
        document.addEventListener('mouseout', (e) => {
          const pill = e.target.closest('.pill-sid[data-stream-id]');
          if (!pill) return;

          clearHoverPreview();
        });

        // ESC key handler to clear selection
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape' && activeStreamId) {
            clearStreamHighlight();
            e.preventDefault();
          }

          // Handle Enter/Space on focused pill
          if ((e.key === 'Enter' || e.key === ' ') &&
              e.target.classList.contains('pill-sid')) {
            e.target.click();
            e.preventDefault();
          }
        });
      }

      // Decompile stream button handler
      async function handleDecompileStream() {
        if (!activeStreamId) {
          toast('No stream selected', 'err');
          return;
        }

        // Store streamId locally to preserve it during async operation
        const streamId = activeStreamId;

        const btn = getDecompileStreamButton();
        const originalText = btn.textContent;
        btn.disabled = true;
        btn.textContent = 'Decompiling...';

        try {
          // Filter frames client-side by matching streamId and optionally connectionId
          const frames = activeFrames();
          const matchingHexFrames = [];

          for (const frameData of frames) {
            const obj = frameData.obj;
            const frameStreamId = extractStreamIdFromHex(obj, 'dec');

            // Check streamId match
            if (frameStreamId !== streamId || !obj.fullHex) {
              continue;
            }

            // Check connection filter if active
            if (selectedConnectionId && obj.connectionId !== selectedConnectionId) {
              continue;
            }

            matchingHexFrames.push(obj.fullHex);
          }

          if (matchingHexFrames.length === 0) {
            btn.disabled = false;
            btn.textContent = originalText;
            const filterMsg = selectedConnectionId
              ? 'No frames with hex data found for selected stream and connection'
              : 'No frames with hex data found for selected stream';
            toast(filterMsg, 'err');
            return;
          }

          // Reverse to match UI display order (newest first)
          matchingHexFrames.reverse();

          // Send frame hex data to server
          const response = await fetch('/api/decompile-stream', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ frames: matchingHexFrames })
          });

          const result = await response.json();

          btn.disabled = false;
          btn.textContent = originalText;

          if (result.success && result.fdoSource) {
            // Unescape newlines and other escape sequences from JSON
            const unescapedSource = result.fdoSource
              .replace(/\\n/g, '\n')
              .replace(/\\r/g, '\r')
              .replace(/\\t/g, '\t');

            // Show modal with custom title including connection info if applicable
            const frameCount = result.frameCount || 0;
            const plural = frameCount !== 1 ? 's' : '';
            let title = `Stream Decompilation: ${streamId} (${frameCount} frame${plural})`;
            if (selectedConnectionId) {
              const conn = connections.find(c => c.connectionId === selectedConnectionId);
              const connLabel = conn ? `${conn.sourceIp}` : selectedConnectionId;
              title = `Stream Decompilation: ${streamId} from ${connLabel} (${frameCount} frame${plural})`;
            }
            showFdoModal(unescapedSource, title
            );
          } else {
            toast(result.error || 'Decompilation failed', 'err');
          }
        } catch (err) {
          btn.disabled = false;
          btn.textContent = originalText;
          toast('Failed to decompile stream: ' + err.message, 'err');
        }
      }

      // Attach handler to both decompile stream buttons in headers
      document.getElementById('decompile-stream-proxy').addEventListener('click', handleDecompileStream);
      document.getElementById('decompile-stream-pcap').addEventListener('click', handleDecompileStream);

      exportJsonlBtn.addEventListener('click', async () => {
        try {
          const currentTab = document.querySelector('.tab.active');
          const isProxyTab = currentTab && currentTab.dataset.tab === 'proxy';
          const isPcapTab = currentTab && currentTab.dataset.tab === 'pcap';

          let lines = [];
          let filename = 'export.jsonl';
          let dataSource = '';

          if (isPcapTab) {
            // Export PCAP analysis data (client-side) with optional connection filtering
            let frames = activeFrames(); // This will return framesPcap when on PCAP tab

            if (frames.length === 0) {
              toast('No PCAP frames to export', 'err');
              return;
            }

            // Apply connection filtering if a connection is selected
            if (selectedConnectionId) {
              frames = frames.filter(frameData => {
                const obj = frameData.obj;
                return obj && obj.connectionId === selectedConnectionId;
              });

              if (frames.length === 0) {
                toast('No frames found for selected connection', 'err');
                return;
              }
            }

            // Convert frame objects to JSONL format
            for (const frameData of frames) {
              try {
                if (frameData.raw) {
                  // Use the raw JSON string if available
                  lines.push(frameData.raw);
                } else if (frameData.obj) {
                  // Convert object to JSON string
                  lines.push(JSON.stringify(frameData.obj));
                }
              } catch (e) {
                console.warn('Failed to process frame for export:', frameData, e);
              }
            }

            // Update filename based on connection filter
            if (selectedConnectionId) {
              const conn = connections.find(c => c.connectionId === selectedConnectionId);
              const connLabel = conn ? `${conn.sourceIp}` : selectedConnectionId;
              filename = `pcap_analysis_${connLabel}.jsonl`;
              dataSource = `PCAP analysis (${connLabel})`;
            } else {
              filename = 'pcap_analysis.jsonl';
              dataSource = 'PCAP analysis (all connections)';
            }

          } else if (isProxyTab) {
            // Export live session data (server-side JSONL stream) with optional connection filtering
            let url = '/api/session/frames';
            if (selectedConnectionId) {
              url += `?connectionId=${encodeURIComponent(selectedConnectionId)}`;
            }

            const response = await fetch(url);
            if (!response.ok) {
              throw new Error(`Failed to fetch session frames: ${response.status}`);
            }

            // Response is now JSONL (newline-delimited JSON), not a JSON array
            const text = await response.text();
            const jsonlLines = text.trim().split('\n').filter(line => line.trim());

            // Each line is already a valid JSON object
            for (const line of jsonlLines) {
              lines.push(line);
            }

            // Generate timestamp-based filename with frame count
            const now = new Date();
            const dateStr = now.toISOString().slice(0, 10).replace(/-/g, '');
            const timeStr = now.toTimeString().slice(0, 8).replace(/:/g, '');
            const frameCountSuffix = lines.length > 0 ? `-${lines.length}f` : '';

            // Update filename and data source based on connection filter
            if (selectedConnectionId) {
              const conn = connections.find(c => c.connectionId === selectedConnectionId);
              const connLabel = conn ? `${conn.sourceIp}` : selectedConnectionId;
              filename = `wiretap-proxy-${dateStr}-${timeStr}-${connLabel}${frameCountSuffix}.jsonl`;
              dataSource = `live session (${connLabel})`;
            } else {
              filename = `wiretap-proxy-${dateStr}-${timeStr}${frameCountSuffix}.jsonl`;
              dataSource = 'live session (all connections)';
            }

          } else {
            toast('Unable to determine data source for export', 'err');
            return;
          }

          if (lines.length === 0) {
            toast(`No ${dataSource} frames to export`, 'err');
            return;
          }

          const blob = new Blob([lines.join('\n') + '\n'], { type: 'application/x-ndjson' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = filename;
          a.click();
          URL.revokeObjectURL(url);

          toast(`Exported ${lines.length} ${dataSource} frames to JSONL`, 'ok');
        } catch (error) {
          console.error('Export failed:', error);
          toast('Failed to export frames', 'err');
        }
      });



      async function startUpload() {
        if (!selectedFile) return;
        // reset UI
        document.getElementById('timeline-pcap').innerHTML = '';
        activeFrames().length = 0;
        firstPcapFrameTs = null;
        // create temp download link anchor lazily
        if (!downloadLink) { downloadLink = document.createElement('a'); downloadLink.style.display='none'; document.body.appendChild(downloadLink); }
        downloadLink.removeAttribute('href');
        downloadLink.setAttribute('download', (selectedFile.name || 'session') + '.summary.jsonl');

        const res = await fetch('/api/upload', {
          method: 'POST',
          headers: { 'Content-Type': 'application/octet-stream' },
          body: selectedFile
        }).catch((e) => ({ ok: false, statusText: e.message }));

        if (!res || !res.ok || !res.body) {
          timelinePcap.innerHTML = '';
          return;
        }

        const reader = res.body.getReader();
        const chunks = [];
        const decoder = new TextDecoder();
        let buffer = '';
        let lineCount = 0;
        while (true) {
          const { value, done } = await reader.read();
          if (done) break;
          chunks.push(value);
          buffer += decoder.decode(value, { stream: true });
          let idx;
          while ((idx = buffer.indexOf('\n')) >= 0) {
            const line = buffer.slice(0, idx);
            buffer = buffer.slice(idx + 1);
            if (!line) continue;
            try {
              const obj = JSON.parse(line);
              activeFrames().push({ obj, raw: line });
              renderFrame(obj, line, document.getElementById('timeline-pcap'));
              lineCount++;
            } catch (e) {
              // ignore malformed lines
            }
          }
        }
        if (buffer) {
          try {
            const obj = JSON.parse(buffer);
            activeFrames().push({ obj, raw: buffer });
            renderFrame(obj, buffer, document.getElementById('timeline-pcap'));
            lineCount++;
          } catch (_) {
            // ignore leftover text
          }
        }
        const blob = new Blob(chunks, { type: 'application/x-ndjson' });
        const url = URL.createObjectURL(blob);
        downloadLink.href = url;
        toast(`Successfully processed ${lineCount} frames`, 'ok');
        document.getElementById('file-type-indicator').textContent = '• PCAP File';
      }

      // Tab switching function
      function switchToTab(tabName) {
        const targetTab = document.querySelector(`[data-tab="${tabName}"]`);
        if (targetTab) {
          // Remove active class from all tabs
          document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
          // Add active class to target tab
          targetTab.classList.add('active');

          // Hide all tab panels
          document.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
          // Show target tab panel
          document.getElementById('tab-' + tabName).classList.add('active');

          // Toggle visible timeline and proxy controls
          const timelineProxy = document.getElementById('timeline-proxy');
          const timelinePcap = document.getElementById('timeline-pcap');
          const proxyControls = document.getElementById('proxy-controls');

          if (tabName === 'proxy') {
            timelineProxy.style.display = '';
            timelinePcap.style.display = 'none';
            proxyControls.style.display = 'block';
            // Update proxy status when switching to proxy tab
            updateProxyStatus();
          } else if (tabName === 'pcap') {
            timelineProxy.style.display = 'none';
            timelinePcap.style.display = '';
            proxyControls.style.display = 'none';
          }

          // Update URL hash without triggering page reload
          window.history.replaceState(null, null, '#/' + tabName);
        }
      }

      // Handle initial hash fragment on page load
      function handleInitialHash() {
        const hash = window.location.hash.substring(1); // Remove the '#'
        // Handle both formats: #/pcap and #pcap
        const cleanHash = hash.startsWith('/') ? hash.substring(1) : hash;
        if (cleanHash === 'live' || cleanHash === 'proxy') {
          switchToTab('proxy');
        } else if (cleanHash === 'pcap') {
          switchToTab('pcap');
        }
      }

      const tabs = document.querySelectorAll('.tab');
      tabs.forEach(t => t.addEventListener('click', () => {
        const tabName = t.dataset.tab;
        switchToTab(tabName);
      }));


      // Handle hash changes (for browser back/forward buttons)
      window.addEventListener('hashchange', () => {
        const hash = window.location.hash.substring(1);
        // Handle both formats: #/pcap and #pcap
        const cleanHash = hash.startsWith('/') ? hash.substring(1) : hash;
        if (cleanHash === 'live' || cleanHash === 'proxy') {
          switchToTab('proxy');
        } else if (cleanHash === 'pcap') {
          switchToTab('pcap');
        }
      });




             // Check initial proxy status on page load
      checkInitialProxyStatus();

      // Handle initial hash fragment for tab navigation
      handleInitialHash();

      // Initialize streamId filtering feature
      initStreamIdFiltering();

      // Periodic session metadata update
      setInterval(() => {
        updateSessionMetadata();
      }, 1000); // Update every second

      // Periodic proxy status check to keep UI in sync
      setInterval(() => {
        if (document.visibilityState === 'visible') { // Only check when page is visible
          fetch('/api/proxy/status')
            .then(res => res.json())
            .then(status => {
              if (status.running !== proxyRunning) {
                proxyRunning = status.running;

                const statusDot = document.getElementById('proxy-status-dot');

                if (status.running) {
                  if (statusDot) statusDot.classList.add('running');
                } else {
                  if (statusDot) statusDot.classList.remove('running');

                  // If proxy stopped unexpectedly, update localStorage
                  localStorage.setItem('proxyRunning', 'false');
                  // Stop live stream if it was connected
                  stopLive();
                }
              }
            })
            .catch(err => {
              // If we can't reach the server, assume proxy is stopped
              if (proxyRunning) {
                proxyRunning = false;
                localStorage.setItem('proxyRunning', 'false');
                stopLive();

                // Update UI to show stopped state
                const statusDot = document.getElementById('proxy-status-dot');

                if (statusDot) statusDot.classList.remove('running');
              }
            });

          // Also check live stream health and reconnect if needed
          if (proxyRunning && !window.es) {
            console.log('Live stream not connected, attempting to reconnect...');
            startLive();
          }
        }
      }, 5000); // Check every 5 seconds

    </script>
  </body>
  </html>