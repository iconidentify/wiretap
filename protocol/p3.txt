P3
 
AOLP3.AOL validates packets, checks and/or creates the CRC, checks and/or creates length, checks or create and Sync, TXseq, RXseq, and type.  It wraps hostbound data it receives from the client with these parameters. It strips inbound packets of these, and the packet header, and sends it to the dispatcher that generally will send out the token and associated data to the tools that have registered themselves to handle the token data.  Outbound packets are limited to 119 data bytes. Inbound packets can be larger. 
 
The P3 Tool is a communications protocol used to ensure error-free transmission between the host and the 
client computer. The data is formed into packets with an 8-byte header and a terminating carriage return. The minimum length of a packet is the header plus carriage return, the nominal length is 128 bytes, and the current maximum length is 1024 bytes.
 
The P3 protocol was designed with the following constraints:
(1)   The protocol must detect any errors in transmission, and make sure that all messages are delivered without error in correct order.
(2)   The number of packets sent should be kept to a minimum.
(3)   The maximum size of a packet, including all headers and trailers must be less than or equal to 128 characters, because of its intended use over packet networks.
 
There are two classes of packets - numbered and unnumbered. Data packets are numbered; all other packets are not. The data packets are numbered consecutively and must be delivered in order.
 
A packet is considered invalid if it is received out of order, with an incorrect length, or bad cyclic redundancy check (CRC). If a data packet is detected as invalid by the P3 tool, a retransmission of all data packets, beginning with the number of the bad packets is requested.  This ensures that the sequence of the packets is maintained.
 
P3 Packet Structure
 
typedef struct packet //Header = 12 bytes followed by data
{
   BYTE sync;
   WORD wCRC;
   WORD wLength;
   BYTE TXseq;
   BYTE RXseq;
   BYTE type;
   BYTE data[1017]; // 1 byte slop for length overrun check...
} PACKET, FAR *LPPACKET;
 
The error detection field within the header consists of a 16-bit CRC (Cyclic Redundancy Check) which has been split into 4 bytes as follows: If the CRC was (using space to separate the bytes) x’WX YZ’, it becomes x’W1 8X Y1 8Z’.  This ensures that none of the CRC codes will ever be a x’0D’.  The CRC used is a standard CRC (CRC-16) for data communications developed by IBM and widely used.  It will catch all errors 16 bits long or less, and 99.955% of those over 16 bits long.
 
The sequence number and response number fields with the header should be in the range of 16-127 (x’10’ – x’7F’).  This will avoid unwanted values and allow for long periods between repeats.  Certain control messages are un-numbered, i.e. their sequence numbers are the same as the last message sent.  When they are received, they will not be ignored or discarded, regardless of their sequence number of the last correct message received.
 
Each sender has a certain number of messages it can buffer for retransmission.  The range of sequence numbers currently in the buffer, plus those available for outgoingt message make up the ‘window’.  The window is typically a small subset of the whole range of possible sequence numbers.
 
The message is terminated by a carriage return (x’0D’).  This enables the packet network pads to collect an entire message before forwarding it along the network.
 
Message types:
 
(1)   INIT (x’23’) – An INIT forces an initialization of communications.  The micro is the only one allowed to send an INIT, and therefore the host can only receive an INIT.  The host will clear its buffers, and set the current response and sequence numbers to the values passed by the INIT.  The macro will continue sending INIT’s periodically until it receives a valid acknowledgement.  The host will not send anything until it has received an INIT.
 
(2)   ACK (x’24’) – An ACK is simply a null, un-numbered message.  It contains the response number of the last correctly received message.  An ACK is normally sent only if the sender (of the ACK) has no traffic to send, and the receiver’s window is filling up past a certain point.  It is also sent in response to a valid INIT and a valid HEARTBEAT (to be described later).
 
(3)   SS (x’21’) – An SS requests the other end of the connection to send an SSR.  If an SS is sent, and no response is received with a given time period (10-20 seconds), it will be re-transmitted.  While waiting on an SSR, the sender (of the SS) will not respond to NAK’s or open its window.
 
(4)   SSR (x’22’) – An SSR is a response to an SS.  It is only sent when an SS is received.  Receiving an SSR will cause the receiver to retransmit any messages that the SSR indicats the sender (of the SSR) has not received.  Before an SSR is sent, the NAK queue is cleared.
 
(5)   NAK (x’25’) – a NAK is sent when a bad message is received (bad message being defined as a bad CRC or an out of sequence message), with certain exceptions.  A NAK tells the receiver to re-transmit starting with a certain message.  A NAK has a sequence number, but it is not discarded if it is out of sequence.  If it is out of sequence, it is processes, and put on a stack of out of sequence NAKs.  If a NAK is received that is a re-transmit of a NAK that was received correctly, but out of sequence, it is ignored.  If a NAK is received while waiting for an SSR, it is ignored.
 
If a message is received incorrectly and the window is closed, it is queued to go out when the window opens.  IF a NAK is already queued, it (the new NAK) is ignored instead.  The NAK queue is cleared if an SS is received, to keep from asking for two re-transmission of the same messages.
 
(6)   DATA (x’20’) – In normal transmission, messages are being passed in both directions.  Each message sent carries the number of the last message correctly received, which is an implicit acknowledgement of all messages up to and including that one.  When a message is received correctly, it is passed up to the application level.  Then the response number of the message is examined.  If it acknowledges any messages currently in the buffer, they are dropped from the buffer.  If the receiver of the message has received a certain number of messages without acknowledging, it will send an ACK to keep the sender’s window from closing.  (A window is closed when the buffer of sent messages is full, preventing any more transmissions.)
 
If a single message gets mangled, the receiver will get a bad checksum, and send a NAK (assuming its window is open) requesting re-transmission of all messages starting at the mangled one.  It will then ignore out of sequence messages until it gets the mangled message correctly.  If its window is closed, and there is no NAK queued, it will queue the NAK for transmission when the window opens.  If there is a NAK queued already, it will ignore the new one.
 
The same NAK logic would apply to messages received out of sequence, assuming that a NAK had not already been sent.
 
In all cases, where a numbered message is sent, the window is checked.  If it is closed, an SS is sent to try to re-open the wondow.  When an SS has been sent, and no SSR has been received, all NAKs are accepted, but they are ignored, instead of being processed.
 
When a SSR is received, any messages that were not received are queued for transmission.  When there is a message to send, and the window is open, it is sent and put into buffer.  If the window is closed, the message is queued for transmission.  This is separate from NAK queue.
 
(7)   HEARTBEAT (x’26’) – If either side of the connection, has an un-acknowledged message for more than some period of time (10-20 seconds), and has not received any communication from the other side, it will transmit a heartbeat.  A heartbeat is an un-numbered message, and the only response to a heartbeat is to send an ACK.
 
Token, Protocol, Class and Atom Data and Size
 
The token is always the first two bytes of the packet data.  In any atomized packet, it's followed by a stream ID and then the atoms.  Atoms can be encoded a number of different ways ("styles"), so where the protocol, atom #, and length are stored depends on the style being used.  The most often used style ("full") is simply:
 
<protocol> <atom> <length>
 
Initialization
 
Once the user is connected to the host a message is sent to CSL that in turn sends a MSG_P3_START message to the P3 ToolMsgHandler.  The P3 tool handler calls a function P3Start that uses the subroutine: SetCommDataCallback(... (LPFN)P3DataHandler) to set up  the P3DataHandler callback function address to be used by the comm port subroutines each time new data comes in.  
 
Runtime
 
Each time new data comes in from the comm port (via AOLMODEM.AOL) the P3DataHandler is called. The comm port data (a P3 packet) is passed to it through its argument list. It handles the P3 packet using a 
function called: HandlePacket which parses the packet and places it in a Queue called: QueueInputPacket. At the end of the P3DataHandler a DispatchPacket subroutine is executed. It sends a message using 
ToolSendMsg to broadcast the P3 data primarily to the ATOMIZER in SUPERSUB.dll. 
 
Downloads come down to the client in 1k packets where uploads come up to the host in 119 byte packets.
 
 
